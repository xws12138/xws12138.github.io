<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>模块的加载机制</title>
    <link href="/2021/02/22/%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <url>/2021/02/22/%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>这是一篇个人总结的，关于 模块的加载机制 的笔记。</p><h2 id="模块优先从缓存中加载"><a href="#模块优先从缓存中加载" class="headerlink" title="模块优先从缓存中加载"></a>模块优先从缓存中加载</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">一、模块优先从缓存中进行加载 <br>    模块在第一次加载后会被缓存, 如果每次调用 require(<span class="hljs-string">&#x27;foo&#x27;</span>) 都解析到同一文件，则返回相同的对象,<br>  不会导致模块的代码被执行多次<br><br>  二、缓存的作用<br>    不论是 node.js 内置的核心模块，用户自定义的模块还是第三方模块，都有对应的缓存策略，提升模块的<br>  加载效率<br><br>  说明：文档地址（http:<span class="hljs-regexp">//</span>nodejs.cn<span class="hljs-regexp">/api/m</span>odules.html<span class="hljs-comment">#modules_caching） </span><br></code></pre></td></tr></table></figure><h2 id="内置模块-核心模块-的加载机制"><a href="#内置模块-核心模块-的加载机制" class="headerlink" title="内置模块(核心模块)的加载机制"></a>内置模块(核心模块)的加载机制</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">一、核心模块的加载机制 <br><span class="hljs-built_in">require</span>() 总是会优先加载核心模块, 比如 <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>) 始终返回内置的 HTTP 模块，即使有同名文件<br><span class="hljs-comment">// http 存在一个同名的第三方包，优先加载内置模块</span><br><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br><span class="hljs-comment">// 自定义模块</span><br><span class="hljs-comment">// const http = require(&#x27;./http&#x27;)</span><br><span class="hljs-built_in">console</span>.log(http);<br></code></pre></td></tr></table></figure><h2 id="自定义模块的加载机制"><a href="#自定义模块的加载机制" class="headerlink" title="自定义模块的加载机制"></a>自定义模块的加载机制</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"> 一、自定义模块的加载机制 <br>      使用 <span class="hljs-built_in">require</span>() 方法去加载自定义模块，必须指定 <span class="hljs-string">&#x27;/&#x27;</span>、 <span class="hljs-string">&#x27;./&#x27;</span> 或 <span class="hljs-string">&#x27;../&#x27;</span> 开头的路径，如果没有这个<br>    路径标识，node 会默认把它当作是一个核心模块或来自 node_modules 目录下的第三方模块<br><br><br>    二、自定义文件模块<br>      如果按确切的文件名没有找到模块，则 Node.js 会尝试带上 .js、 .json 或 .node 拓展名再加载<br><br>    三、自定义目录模块<br>      当传递一个目录标识符给 <span class="hljs-built_in">require</span> () 方法时, 加载的顺序如下:<br>      <br>      <span class="hljs-number">1.</span> 在加载的目录下查找 package.json 的文件, 并寻找 main 属性作为 <span class="hljs-built_in">require</span> 的入口<br>      <span class="hljs-number">2.</span> 上述找不到,  Node.js 将会试图加载目录下的 index.js 或 index.node 文件<br><br><span class="hljs-comment">// 1. 引入自定义模块</span><br><span class="hljs-comment">// const foo = require(&#x27;./foo&#x27;)</span><br><span class="hljs-comment">//     // 在导入自定义模块时 如果省略了文件的扩展名，则node.js 会按照顺序分别尝试加载以下的文件</span><br><span class="hljs-comment">//     // 先找 .js， 如果没有</span><br><span class="hljs-comment">//     // 再找 .json， 没有</span><br><span class="hljs-comment">//     // 再再找 .node， 也没有</span><br><span class="hljs-comment">//     // 报错</span><br><span class="hljs-comment">// console.log(foo);</span><br><br><span class="hljs-comment">// --------------------------------------------------------------------------------------------</span><br><span class="hljs-comment">// 2.引入自定义目录模块</span><br><span class="hljs-keyword">const</span> res = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./custom&#x27;</span>)<br><span class="hljs-built_in">console</span>.log(res);<br><span class="hljs-comment">// 在导入自定义目录模块时 如果package.json文件里面没有 main 属性 或者 main 属性没有指定一个目标文件 </span><br><span class="hljs-comment">// 那么 node.js 会直接找 目录下名为 index.js 或 index.node 文件，如果也没有则报错</span><br><span class="hljs-comment">// 如果 package.json文件里面的 main 属性指定了一个目标文件，那么 node.js 会去找 mian 属性指定的文件</span><br></code></pre></td></tr></table></figure><h2 id="第三方模块的加载机制"><a href="#第三方模块的加载机制" class="headerlink" title="第三方模块的加载机制"></a>第三方模块的加载机制</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">一、第三方模块的加载机制 <br>     如果传递给 <span class="hljs-built_in">require</span>() 的模块标识符不是一个核心模块，也没有以 <span class="hljs-string">&#x27;/&#x27;</span> 、 <span class="hljs-string">&#x27;../&#x27;</span> 或 <span class="hljs-string">&#x27;./&#x27;</span> 开头，<br>   那么 Node.js 会从当前模块的父目录开始，尝试从它的 /node_modules 目录里加载模块。如果还是没有找到，<br>   则移动到再上一层父目录，直到文件系统的根目录。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>npm相关命令</title>
    <link href="/2021/02/22/npm%E5%91%BD%E4%BB%A4/"/>
    <url>/2021/02/22/npm%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>这是一篇个人总结的，关于 npm相关命令 的笔记。</p><h2 id="npm-管理包的命令"><a href="#npm-管理包的命令" class="headerlink" title="npm 管理包的命令"></a>npm 管理包的命令</h2><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">一、下载一个指定的包 <br>    `npm install 包的具体名称`<br>     可以简写为：<br>    `npm i 包的具体名称` <br><br>二、查看一个指定包<br>    `npm view 包的具体名称`<br><br>三、下载指定版本的包<br>     `npm i 包的具体名称@版本号`<br></code></pre></td></tr></table></figure><h2 id="快速创建包管理配置文件"><a href="#快速创建包管理配置文件" class="headerlink" title="快速创建包管理配置文件"></a>快速创建包管理配置文件</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">一、快速创建包管理配置文件 <br><span class="hljs-code">    在项目的根目录下执行 `npm init -y` 命令</span><br><span class="hljs-code"></span><br><span class="hljs-code">注意：</span><br><span class="hljs-code">    1. 项目目录不能使用中文命名, 不能包含空格</span><br><span class="hljs-code">    2. 创建了 package.json 文件后, 每次安装包的名称和版本都会记录在这个文件中，不需要手动修改</span><br><span class="hljs-code"></span><br></code></pre></td></tr></table></figure><h2 id="卸载指定的包"><a href="#卸载指定的包" class="headerlink" title="卸载指定的包"></a>卸载指定的包</h2><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">一、卸载指定的包 <br>      执行 `npm uninstall 包名称` 不可简写<br><br>    注意：<br>      <span class="hljs-number">1</span>. 当命令执行成功后，dependencies 配置项下的包会自动移除<br>      <span class="hljs-number">2</span>. 卸载包的时候不需要指定版本号<br></code></pre></td></tr></table></figure><h2 id="devDependencies-配置作用以及如何安装开发测试阶段用到的包"><a href="#devDependencies-配置作用以及如何安装开发测试阶段用到的包" class="headerlink" title="devDependencies 配置作用以及如何安装开发测试阶段用到的包"></a>devDependencies 配置作用以及如何安装开发测试阶段用到的包</h2><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">一、devDependencies 配置作用 <br>      只在本地开发测试阶段需要用到的包，一般记录在 devDependencies 配置项中，后期在进行项目打包上线的<br>    时候，并不会把这些包携带到线上环境<br><br>二、如何安装开发测试阶段用到的包<br>      执行命令 `npm i --save-dev 包名称@版本号` 或 `npm i -D 包名称@版本号`<br></code></pre></td></tr></table></figure><h2 id="解决包下载速度慢的问题-切换下载源命令"><a href="#解决包下载速度慢的问题-切换下载源命令" class="headerlink" title="解决包下载速度慢的问题: 切换下载源命令"></a>解决包下载速度慢的问题: 切换下载源命令</h2><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">一、npm 下载包的问题 <br>    当我们下载国外服务器上的包时，网速较慢容易下载失败， 可以考虑把下载包的服务器（源）进行更换<br><br>  二、更换国内的源<br><span class="hljs-title">    在任意目录下执行： `npm config set registry=https:</span>//registry.npm.taobao.org`<br>    检查源有没有更换成功： `npm config get registry`<br><br>  三、使用 nrm 切换源<br>    在任意目录下依次执行：`npm i -g nrm` ==&gt; `nrm ls` ==&gt;`nrm use taobao`<br></code></pre></td></tr></table></figure><h2 id="包的分类，安装全局包命令"><a href="#包的分类，安装全局包命令" class="headerlink" title="包的分类，安装全局包命令"></a>包的分类，安装全局包命令</h2><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> 的包从作用域上可以分为： <br><span class="hljs-number">1.</span> 项目包： 被安装到项目的 node_modules 目录中的包，只能在当前项目下进行使用<br>  - [核心依赖包] 线上环境用到的依赖包： <span class="hljs-built_in">npm</span> i 包名称<br>  - [开发依赖包] 开发测试环境用到的依赖包：<span class="hljs-built_in">npm</span> i -D 包名称<br><br><span class="hljs-number">2.</span> 全局包： 被下载到 node 安装位置 node_modules 目录下的包，可以在全局范围(任意目录)内使用<br>  安装命令： <span class="hljs-built_in">npm</span> i -g 包名称<br>  卸载命令： <span class="hljs-built_in">npm</span> uninstall -g 包名称<br><br>注意: 具有全局工具性的包才有全局安装的必要性, 可以参考 <span class="hljs-built_in">npm</span> 官网中对包的说明<br></code></pre></td></tr></table></figure><h2 id="演示一个全局包的作用，使用全局命令把-md-文件转换成-html-文件"><a href="#演示一个全局包的作用，使用全局命令把-md-文件转换成-html-文件" class="headerlink" title="演示一个全局包的作用，使用全局命令把 md 文件转换成 html 文件"></a>演示一个全局包的作用，使用全局命令把 md 文件转换成 html 文件</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">使用一个把 markdown 格式的文档转成 html 格式文件的工具包<br> <span class="hljs-number">1</span>. 安装全局包： npm i <span class="hljs-literal">-g</span> i5ting_toc <br> <span class="hljs-number">2</span>. 使用全局命令： `i5ting_toc <span class="hljs-operator">-f</span> 要转换的<span class="hljs-built_in">md</span>文件 index.html`<br></code></pre></td></tr></table></figure><h2 id="发布包的命令-步骤"><a href="#发布包的命令-步骤" class="headerlink" title="发布包的命令 (步骤)"></a>发布包的命令 (步骤)</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs markdown">发布包的步骤:<br><span class="hljs-bullet">  1.</span> 编写包的说明文档 <br>  在包的根目录下添加文件 README.md 文件<br><br><span class="hljs-bullet">  2.</span> 注册一个 npm 账号<br>  打开注册网址: https://www.npmjs.com/signup<br><br><span class="hljs-bullet">  3.</span> pc端打开注册邮箱进行确认<br>  点击蓝色按钮 Verify Email<br><br><span class="hljs-bullet">  4.</span> 在包的发布目录下面执行命令<br>  <span class="hljs-code">`npm publish`</span><br><br><span class="hljs-bullet">  5.</span> 删除已经发布的包<br>  <span class="hljs-code">`npm unpublish 包名称 --force`</span><br> <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于js高级的内容笔记</title>
    <link href="/2021/01/28/xws/"/>
    <url>/2021/01/28/xws/</url>
    
    <content type="html"><![CDATA[<p>这是一篇个人总结的，关于js高级部分的知识点笔记。</p><h2 id="js高级第一天"><a href="#js高级第一天" class="headerlink" title="js高级第一天"></a>js高级第一天</h2><h3 id="1-面向对象"><a href="#1-面向对象" class="headerlink" title="1.面向对象"></a>1.面向对象</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">一、面向对象编程 (OOP)<br>  把功能事务分解成一个个对象，通过对象之间的分工合作来完成<br><br>  ex: 把大象放进冰箱<br>  面向对象：1. 大象（走进去） 2. 冰箱（开关门）<br><br>  ex: 小明今天买了一本书<br>  面向对象: 1. 小明 2. 书<br><br>二、面向对象 [高内聚, 低耦合]  vs 面向过程<br>  面向对象：易于维护、拓展，耦合性低；适用场景：多人合作的复杂项目<br>  面向过程：不易于维护、拓展，耦合性高；适用场景：简单的功能模块<br></code></pre></td></tr></table></figure><h3 id="2-类和对象"><a href="#2-类和对象" class="headerlink" title="2.类和对象"></a>2.类和对象</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">  一、类（构造函数）和对象的概念<br>  类 (泛指一类事物)：比如运动员，把公共的特征提取出来，封装在一个模板中（姓名，年龄，身高，特长...）<br>  对象（特指一个具体事物）：把类进行实例化，得到的具体的对象 比如：<br><br>二、面向对象的思维角度<br>  ex: 小明今天买了一本 JS高级程序设计<br>  面向对象: <br><br>  不局限在某个具体的功能，而是抽取核心的公共特征（属性和方法），再创建能实现功能的对象<br><br>三、面向对象的三个特性<br>  1. 封装性：把公共的特征提取出来，封装在一个模板中<br>  2. 继承性：类进行实例化，得到的具体的对象<br>  3. 多态性：生成多个对象<br></code></pre></td></tr></table></figure><h3 id="3-创建类和生成实例"><a href="#3-创建类和生成实例" class="headerlink" title="3.创建类和生成实例"></a>3.创建类和生成实例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">ES6 中使用 class 声明创建一个基于原型继承的具有指定名称的类<br>    一、如何定义一个类<br>      class 类名 &#123;<br>        // 构造函数: 定义公共的属性<br>        constructor (参数) &#123; <br>          this.属性名 = 属性值<br>        &#125;<br><br>        // 类方法: 定义公共的行为<br>        方法名1 (参数) &#123;  &#125;<br>        方法名2 (参数) &#123;  &#125;<br>      &#125;<br>     <br>     二、注意要点<br>      1. class 创建的类首字母还是要大写<br>      2. 类中的 constructor 构造函数, 接收 new 创建对象传递的参数，并返回实例对象（<span class="hljs-built_in">return</span> this）<br>      3. new 一个类时，自动调用构造函数方法，但不会自动调用类方法<br>      4. 类中的构造函数 和 类方法不需要加 <span class="hljs-keyword">function</span> （重点）<br>      5. 多个类方法之间不需要使用逗号隔开 (重点)<br><br>     三、大括号总结<br>      1. 函数体 <span class="hljs-function"><span class="hljs-title">fn</span></span> () &#123;&#125;<br>      2. 定义对象 var obj = &#123;&#125;<br>      3. 条件语法 <span class="hljs-function"><span class="hljs-title">if</span></span> () &#123;&#125;<br>      4. 定义一个类 class 类名 &#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="4-类继承exetnds和super关键字"><a href="#4-类继承exetnds和super关键字" class="headerlink" title="4.类继承exetnds和super关键字"></a>4.类继承exetnds和super关键字</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs bash">1. 定义一个类（子类）通过 extends 继承父类上的方法和属性<br>   class 子类名 extends 父类 &#123;&#125;<br><br>   2. super 关键字可以访问和调用父类上的函数，包括构造函数和类方法<br><br>   注意：<br>   （1）子类调用方法时的查找顺序：先从子类上找再从父类上找<br>   （2）super 作为一个函数，可以调用父类的构造函数；作为一个对象，可以调用父类的方法<br><br>    ------------实例---------------------------------------------------------------------<br>       &lt;script&gt;<br>       // 1,创建一个 人类 People  class 创建的类首字母还是要大写<br>       class People &#123;<br>           // 类中的 constructor 构造函数, 接收 new 创建对象传递的参数，并返回实例对象<br>           constructor(name, age, height) &#123;<br>                   this.name = name<br>                   this.age = age<br>                   this.height = height<br>               &#125; // 多个类方法之间不需要使用逗号隔开 (重点)<br>               // 定义一个类方法<br>           sing(song) &#123;<br>               console.log(this.name + <span class="hljs-string">&#x27;唱了一首&#x27;</span> + song);<br>           &#125;<br>       &#125;<br>       // 2，创建一个学生类 作为 People的子类<br>       class Student extends People &#123; //用 extends 关键字 加 父类名 才能继承父类的构造方法和类方法<br>           constructor(name, age, height) &#123;<br>                   // 2.1 在构造函数中要想使用 this 必须调用 super()函数，可以直接把参数传给父类的构造方法去调用<br>                   super(name, age, height)<br>               &#125;<br>               // 如果子类没有方法 则直接用父类的<br>               // 如果子类有和父类名字相同的方法 会使用就近原则 执行子类的方法<br>           sing(song) &#123;<br>                   console.log(this.name + <span class="hljs-string">&#x27;跳了一支&#x27;</span> + song);<br>               &#125;<br>               // super还可以在子类的方法中 去调用父类的方法<br>           intro(song) &#123; //子类方法<br>               super.sing(song) //调用父类方法 sing 参数不能忘 song<br>               console.log(this.name + <span class="hljs-string">&#x27;拒绝唱跳&#x27;</span> + song);<br><br>           &#125;<br>       &#125;<br>       // 实例化子类 Student 创建 沈剑心这个对象<br>       var w = new Student(<span class="hljs-string">&#x27;沈剑心&#x27;</span>, 19, 170)<br>       var s = new Student(<span class="hljs-string">&#x27;李忘生&#x27;</span>, 60, 175)<br>       console.log(w, s);<br>       // 使用类方法 对象.方法名<br>       w.sing(<span class="hljs-string">&#x27;猪八戒&#x27;</span>)<br>       s.sing(<span class="hljs-string">&#x27;猪八戒&#x27;</span>)<br>       w.intro(<span class="hljs-string">&#x27;猪八戒&#x27;</span>)<br>       s.intro(<span class="hljs-string">&#x27;猪八戒&#x27;</span>)<br>   &lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="5-super必须放到this之前"><a href="#5-super必须放到this之前" class="headerlink" title="5.super必须放到this之前"></a>5.super必须放到this之前</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs bash">子类中注意的两点：<br>     1. 子类中使用 this 之前，必须要先调用 super<br><br>     2. 子类可以拓展自己的属性和方法<br><br> ------------实例---------------------------------------------------------------------<br>         &lt;script&gt;<br>       // 创造一个父类 Father<br>       class Father &#123;<br>           // 构造函数<br>           constructor(x, y) &#123;<br>                   this.x = x<br>                   this.y = y<br>               &#125;<br>               // 方法<br>           <span class="hljs-function"><span class="hljs-title">sing</span></span>() &#123;<br>               console.log(this.x + this.y);<br>           &#125;<br>       &#125;<br>       // 创造一个子类 Son<br>       class Son extends Father &#123; //获取父类<br>           constructor(x, y, z) &#123; //多一个参数 z <br>               super(x, y) //只传入 x, y<br>               this.z = z //this 必须在 suoer 下面<br>           &#125;<br>           <span class="hljs-function"><span class="hljs-title">sing</span></span>() &#123; //子类的方法 与父类方法同名会就近原则调用子类的<br>               console.log(this.x + this.y + this.z); //自己的方法<br>           &#125;<br>       &#125;<br>       //实例化子类 Son<br>       var w = new Son(10, 20, 30)<br>       w.sing() //调用子类方法 sing 子类方法比父类多一位 z 所以结果是 60<br>           // -------------------------------------------------------------------------------------------------------------------<br>           // 实例化父类 Father<br>       var a = new Father(10, 20, 30) //虽然传了三个参数 但是父类方法只有 x y 两个参数运算 所以第三个传与不传 都不会运算 <br>           // 调用父类方法 与子类同名的 sing<br>       a.sing()<br>   &lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="6-使用类的两个要点"><a href="#6-使用类的两个要点" class="headerlink" title="6.使用类的两个要点"></a>6.使用类的两个要点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">一、使用类的两个注意事项<br>  1. 声明 class 类不存在变量提升，先定义再使用<br>  2. 在类中访问属性和方法，必须加 this<br></code></pre></td></tr></table></figure><h3 id="7-类中的this指向问题"><a href="#7-类中的this指向问题" class="headerlink" title="7.类中的this指向问题"></a>7.类中的this指向问题</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;<br>      // 定义一个全局变量 that<br>      var that<br>      class Foo &#123;<br>          constructor(x, y) &#123;<br>              // 默认指向创建出来的实例对象<br>              console.log(this);<br>              // 把 this 赋值给 that<br>              that = this<br>              this.x = x<br>              this.y = y<br>              this.btn = document.querySelector(<span class="hljs-string">&#x27;button&#x27;</span>) //获取按钮<br>                  //为按钮绑定点击事件，要使用类中的属性和方法前面必须加 this<br>                  //注意: 1.此时 getsum 函数是通过 btn 按钮来调用的 所以 getsum 里面的 this 指向 btn 按钮 按钮里面 没有 x y 所以是空<br>              this.btn.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, this.getsum)<br>          &#125;<br>          <span class="hljs-function"><span class="hljs-title">getsum</span></span>() &#123;<br>              console.log(that); //这里打印的就是 实例对象 而不是 getaum 函数的调用者<br>              console.log(this.x + this.y);<br><br>          &#125;<br>      &#125;<br>      // 创建实例对象 constructor 里面的 this 指向的是 obj 实例对象<br>      var obj = new Foo(1, 2)<br>          // 2. 使用 obj 去调用 getsum 函数 使用 this 指向 obj  obj 实例对象里面有 x y 所以可以执行<br>      obj.getsum()<br>  &lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="js高级第二天"><a href="#js高级第二天" class="headerlink" title="js高级第二天"></a>js高级第二天</h2><h3 id="1-构建函数创建对象"><a href="#1-构建函数创建对象" class="headerlink" title="1.构建函数创建对象"></a>1.构建函数创建对象</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;<br>       // 使用构造函数创建对象<br>       <span class="hljs-keyword">function</span> fn(name, age, sex) &#123;<br>           // 属性<br>           this.name = name,<br>               this.age = age,<br>               this.sex = sex<br>               // 方法 say<br>           this.say = <span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>               console.log(<span class="hljs-string">&#x27;hello&#x27;</span>);<br><br>           &#125;<br>       &#125;<br>       // new 一个构造函数创建对象<br>       var w = new fn(<span class="hljs-string">&#x27;沈剑心&#x27;</span>, 18, <span class="hljs-string">&#x27;男&#x27;</span>)<br>       console.log(w);<br>       // 调用方法<br>       w.say()<br>           // ---------------------------------------------------------------<br>           //1 字面量形式<br>       var obj = &#123;<br>           name: <span class="hljs-string">&#x27;沈剑心&#x27;</span>,<br>           age: 18,<br>           sex: <span class="hljs-string">&#x27;男&#x27;</span><br>       &#125;<br>       console.log(obj);<br>       // ---------------------------------------------------------------<br>       // 2. new Object()<br>       var obj2 = new Object() //得到一个空对象<br>       obj2.name = <span class="hljs-string">&#x27;沈剑心&#x27;</span><br>       obj2.age = 18<br>       obj2.sex = <span class="hljs-string">&#x27;男&#x27;</span><br>       console.log(obj2);<br>   &lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="2-静态成员和实例成员"><a href="#2-静态成员和实例成员" class="headerlink" title="2.静态成员和实例成员"></a>2.静态成员和实例成员</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;<br>        // 使用构造函数创建对象<br>        <span class="hljs-keyword">function</span> fn(name, age, sex) &#123;<br>            // 属性<br>            this.name = name,<br>                this.age = age,<br>                this.sex = sex<br>                // 方法 say<br>            this.say = <span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>                console.log(<span class="hljs-string">&#x27;hello&#x27;</span>);<br><br>            &#125;<br>        &#125;<br>        // 1. 实例成员: 只能通过实例对象才能访问的属性或方法 name, age, sex 都是实例成员<br>        // new 一个构造函数创建对象  实例对象 w<br>        var w = new fn(<span class="hljs-string">&#x27;沈剑心&#x27;</span>, 18, <span class="hljs-string">&#x27;男&#x27;</span>)<br>        console.log(w.name); //实例成员只能通过实例对象来访问<br>        console.log(fn.name); //不能通过函数本身来访问<br><br>        // -------------------------------------------------------------------------------------<br>        // 2. 静态成员: 只能通过构造函数本身才能访问的属性或方法<br>        fn.heigth = 170 //给 fn 函数添加一个 heigth 属性 并赋值<br>        console.log(fn.heigth); //只能通过函数本身才能访问<br>        console.log(w.heigth); // 不能通过实例对象 w 进行访问 因为实例对象里面没有 heigth <br>        // 这个heigth添加在 fn 函数本身里<br>        // 所以就是undefined<br>    &lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="3-构造函数的原型"><a href="#3-构造函数的原型" class="headerlink" title="3.构造函数的原型"></a>3.构造函数的原型</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs bash">一、构造函数中直接添加方法的缺点<br>  每次创建对象，要重复开辟内存空间，浪费资源 <br><br>二、构造函数的原型 prototype<br>  1. 每个函数默认都有一个 propotype 属性, 它的值默认是一个对象<br>  2. 在 prototype 对象上的方法和属性, 会被 new 构造函数() 创建出来的实例对象所继承<br><br>三、注意:<br>  (1) 只要是函数就默认有 prototype 属性, 但非函数的对象是不具有的<br>  (2) 定义构造函数时, 公共的方法定义在原型对象上, 这样可以被所有创建出来的实例直接继承<br> ------------实例---------------------------------------------------------------------<br>  &lt;script&gt;<br>    <span class="hljs-keyword">function</span> Fn(name, age, sex) &#123;<br>        this.name = name<br>        this.age = age<br>        this.sex = sex<br>            // 1.构造函数中直接添加方法的缺点<br>            // 每次创建对象，要重复开辟内存空间，浪费资源 <br>            // this.say = <span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>            //     console.log(<span class="hljs-string">&#x27;你好&#x27;</span>);<br>            // &#125;<br>    &#125;<br>    // 2. 每个函数默认都有一个 propotype 属性, 它的值默认是一个对象<br>    // 在构造函数的原型 prototype 上添加方法 这样这个方法就是共享的 所有的实例对象都可以使用<br>    // 定义构造函数时, 公共的方法定义在原型对象上, 这样可以被所有创建出来的实例直接继承<br>    Fn.prototype.say = <span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>            console.log(<span class="hljs-string">&#x27;hello&#x27;</span>);<br>        &#125;<br>        //3. 直接给共享方法添加一个属性 abc 这个属性可以被实例对象所继承(不会是静态成员)<br>    Fn.prototype.abc = 123<br>        // ----------------------------------------------------------------------------------------------------<br>    var sjx = new Fn(<span class="hljs-string">&#x27;沈剑心&#x27;</span>, 18, <span class="hljs-string">&#x27;男&#x27;</span>)<br>    var lf = new Fn(<span class="hljs-string">&#x27;李复&#x27;</span>, 18, <span class="hljs-string">&#x27;男&#x27;</span>)<br>    console.log(sjx.name);<br>    sjx.say() //都可以调用 say 方法<br>    lf.say() //都可以调用 say 方法<br>    console.log(sjx.abc); //实例对象可以调用 abc 属性<br>    console.log(lf.abc); //实例对象可以调用 abc 属性<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="4-对象原型-proto"><a href="#4-对象原型-proto" class="headerlink" title="4.对象原型 proto"></a>4.对象原型 <strong>proto</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs bash">一、对象的原型<br> 每个对象都默认有一个 __proto__ 的属性, 它的值是一个对象, 默认指向创建这个对象的构造函数的原型<br><br> 二、对象原型的访问特点<br>  每个对象访问 __proto__ 下的所有属性和方法，可以省略__proto__<br><br> 三、对象上读取属性的顺序<br>   先从自身的属性上进行查找，如果没有再去 __proto__ 属性指向的对象上去查找<br>        ------------实例---------------------------------------------------------------------<br>         &lt;script&gt;<br>     <span class="hljs-keyword">function</span> Fn(name, age, sex) &#123;<br>         this.name = name<br>         this.age = age<br>         this.sex = sex<br>         this.set = <span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>             console.log(<span class="hljs-string">&#x27;你好&#x27;</span>);<br><br>         &#125;<br>     &#125;<br>     Fn.prototype.set = <span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>         console.log(<span class="hljs-string">&#x27;hello&#x27;</span>);<br><br>     &#125;<br>     var w = new Fn(<span class="hljs-string">&#x27;沈剑心&#x27;</span>, 18, <span class="hljs-string">&#x27;男&#x27;</span>)<br>         // 对象的原型  __proto__ 的属性 指向这个对象的构造函数的原型 prototype<br>     console.log(w.__proto__ === Fn.prototype);<br>     // 每个对象访问 __proto__ 下的所有属性和方法<br>     // 完整写法  <br>     w.__proto__.set() //如果构造函数自己里面有 <span class="hljs-built_in">set</span> 方法 他也不会找 因为完整写法限制找的范围 只找 __proto__  上面的<br>         // 可以省略__proto__ <br>     w.set() //如果构造函数自己里面有 <span class="hljs-built_in">set</span> 方法 就近原则 先找自己的 自己没有才会去 __proto__ 上面找<br> &lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="5-constructor构造函数"><a href="#5-constructor构造函数" class="headerlink" title="5.constructor构造函数"></a>5.constructor构造函数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;<br>        <span class="hljs-keyword">function</span> Student(name, age, sex) &#123;<br>            this.name = name<br>            this.age = age<br>            this.sex = sex<br>        &#125;<br>        Student.prototype = &#123;<br>            // 当我们重新建立一个对象去覆盖原先的 prototype 时， constructor 属性需要手动赋值<br>            constructor: Student,<br>            <span class="hljs-built_in">set</span>: <span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>                console.log(<span class="hljs-string">&#x27;hello&#x27;</span>);<br>            &#125;,<br>            // 重新创建一个对象 构造函数地址值改变 此时 constructor 属性找不到原来的构造函数<br>            say: <span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>                console.log(<span class="hljs-string">&#x27;hello&#x27;</span>);<br>            &#125;<br>        &#125;<br>        var w = new Student(<span class="hljs-string">&#x27;沈剑心&#x27;</span>, 18, <span class="hljs-string">&#x27;男&#x27;</span>)<br>            // 每个构造函数的原型上 默认都有一个 constructor 属性 他指向构造函数<br>        console.log(Student.prototype.constructor);<br>        console.log(w.constructor); //为了帮助我们判断这个对象是谁创建出来的<br>    &lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="6-构造函数，对象原型，实例"><a href="#6-构造函数，对象原型，实例" class="headerlink" title="6.构造函数，对象原型，实例"></a>6.构造函数，对象原型，实例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">1. 每个构造函数都有一个 prototype 属性, 只要是这个构造函数生成的实例对象, 都会继承 prototype 的属性值<br><br><br>2. 每个对象都有一个 __proto__ 属性，指向创建对象时构造函数的原型对象 prototype;<br><br><br>3. 每个原型对象上默认都有一个 constructor 属性，它指向构造函数本身<br></code></pre></td></tr></table></figure><h3 id="7-原型链"><a href="#7-原型链" class="headerlink" title="7.原型链"></a>7.原型链</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash">原型链理解（面试常问）<br> 每个实例对象（ object ）都有一个私有属性（称之为 __proto__ ）指向创建它的构造函数的原型对象（prototype ）。<br> 该原型对象也有一个自己的原型对象( __proto__ ) ，层层向上直到一个对象的原型对象为 null。<br><br> 注意: 根据定义，null 没有原型，并作为这个原型链中的最后一个环节<br>      ------------实例---------------------------------------------------------------------<br>  &lt;script&gt;<br>       <span class="hljs-keyword">function</span> Student(name, age, sex) &#123;<br>           this.name = name<br>           this.age = age<br>           this.sex = sex<br>       &#125;<br>       Student.prototype.set = <span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>           console.log(<span class="hljs-string">&#x27;hello&#x27;</span>);<br>       &#125;<br>       var w = new Student(<span class="hljs-string">&#x27;沈剑心&#x27;</span>, 18, <span class="hljs-string">&#x27;男&#x27;</span>)<br>       var wh = new Student(<span class="hljs-string">&#x27;李复&#x27;</span>, 18, <span class="hljs-string">&#x27;男&#x27;</span>)<br>       w.set()<br>       console.log(Student.prototype); //这个原型本身也是对象，只要有对象就有 __proto__<br>       // ---------------------------------------------------------------------------------------<br>       //原型对象上的 __proto__ 指向创建这个原型的构造函数(Objext)的原型<br>       console.log(Student.prototype.__proto__ === Object.prototype);<br>       // ---------------------------------------------------------------------------------------<br>       // Object 原型上的 __proto__ 属性值始终为 null ，是原型链的终点<br>       console.log(Object.prototype.__proto__); //null<br>   &lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="8-对象属性查找规则"><a href="#8-对象属性查找规则" class="headerlink" title="8.对象属性查找规则"></a>8.对象属性查找规则</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash">第二点: 对象访问属性时遵从原型链的顺序<br>(1) 当访问一个对象的属性时，首先从这个对象自身进行查找<br>(2) 如果没有找到就从它的原型对象（__proto__）中查找<br>(3) 如果还没有找到，继续沿着对象的原型链层层向上查找，直到最末尾的 null<br> ------------实例---------------------------------------------------------------------<br>  &lt;script&gt;<br>    <span class="hljs-keyword">function</span> Student(name, age, sex) &#123;<br>        this.name = name<br>        this.age = age<br>        this.sex = sex<br>    &#125;<br>    Student.prototype.set = <span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>        console.log(<span class="hljs-string">&#x27;hello&#x27;</span>);<br>    &#125;<br>    var w = new Student(<span class="hljs-string">&#x27;沈剑心&#x27;</span>, 18, <span class="hljs-string">&#x27;男&#x27;</span>)<br>    var wh = new Student(<span class="hljs-string">&#x27;李复&#x27;</span>, 18, <span class="hljs-string">&#x27;男&#x27;</span>)<br><br>    console.log(w.name); //访问实例对象本身的属性<br>    w.set() //访问构造函数原型上的方法<br>    console.log(w.toString()); //访问的是 Object 原型上的方法<br>    Object.prototype.gender = <span class="hljs-string">&#x27;man&#x27;</span><br>    console.log(w.gender);<br>    console.log(w.hll); //找不到 hll 默认结果是 undefined<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="9-原型对象中的-this-指向"><a href="#9-原型对象中的-this-指向" class="headerlink" title="9.原型对象中的 this 指向"></a>9.原型对象中的 this 指向</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash">  (1)非函数中的 this 默认指向 window <br>  (2)函数中的 this 默认指向函数的调用者<br>  ------------实例---------------------------------------------------------------------<br>&lt;script&gt;<br>      <span class="hljs-keyword">function</span> Student(name, age, sex) &#123;<br>          this.name = name<br>          this.age = age<br>          this.sex = sex<br>      &#125;<br>      Student.prototype.set = <span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>          console.log(this === w); //检查 this 是不是指向 w <br>          console.log(this === Student.prototype);; //检查 this 是不是指向 Student.prototype<br>      &#125;<br>      var w = new Student(<span class="hljs-string">&#x27;沈剑心&#x27;</span>, 18, <span class="hljs-string">&#x27;男&#x27;</span>)<br>      var wh = new Student(<span class="hljs-string">&#x27;李复&#x27;</span>, 18, <span class="hljs-string">&#x27;男&#x27;</span>)<br>          //注意！！！函数中的 this 默认指向函数的调用者<br>          // --------------------------------------------<br>          //函数 <span class="hljs-built_in">set</span> 里的 this 指向他的调用者 w 也就是实例对象<br>      w.set()<br>          //函数 <span class="hljs-built_in">set</span> 里的 this 指向他的调用者  Student.prototype<br>      Student.prototype.set()<br>  &lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="10-拓展原型对象上的方法"><a href="#10-拓展原型对象上的方法" class="headerlink" title="10.拓展原型对象上的方法"></a>10.拓展原型对象上的方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;<br>       // 原型链的应用：拓展内置对象上自定义方法<br>       var arr = [1, 2, 3, 4]<br>           // 1. 需求：修改数组 Array 上的原型对象，添加自定义求和的方法<br>       Array.prototype.getSum = <span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>           console.log(this);<br>           var sum = 0<br>           <span class="hljs-keyword">for</span> (var i = 0; i &lt; this.length; i++) &#123;<br>               sum += this[i]<br>           &#125;<br>           <span class="hljs-built_in">return</span> sum<br>       &#125;<br>       console.log(arr.getSum());<br><br>       // 2. 拓展原型对象上的方法时，不能直接覆盖原来的原型对象，只能添加或和修改方法<br>       // 注意：内置对象（如：Object, Array, Function） 上的原型对象不允许进行覆盖，只允许修改<br>       // Array.prototype = <span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>       //     this.name = name<br>       // &#125;<br>   &lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="11-call方法的作用"><a href="#11-call方法的作用" class="headerlink" title="11.call方法的作用"></a>11.call方法的作用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;<br>        // call 和 apply 方法可以修改函数调用时 this 的指向（面试常问 !!!）<br>        <span class="hljs-keyword">function</span> foo(x, y, z) &#123;<br>            console.log(112);<br>            console.log(this);<br>            console.log(x + y + z);<br><br>        &#125;<br>        // 2. call 方法可以去调用函数，并修改函数中 this 指向<br>        // 格式： fn.call([对象, 参数])<br>        // call 方法可以去调用函数<br><br>        console.log(foo.call()); //没有传this指向目标，和参数，所以是undefined<br><br>        // 修改函数中 this 指向 将 this 指向修改为一个数组  [1, 2, 3]<br>        // 将 foo 中的 this 指向 [1, 2, 3]<br>        foo.call([1, 2, 3], 1, 2, 3) //注意，第一位是要修改的指向(也就是你要指向的目标)数组 [1, 2, 3]   后面的是实参<br>            // 注意:<br>            // call 方法的第一个参数就是用来改变函数调用时的 this 指向, 后面的参数才是正常调用函数传递的实参<br>    &lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="12-使用父类构造函数继承属性"><a href="#12-使用父类构造函数继承属性" class="headerlink" title="12.使用父类构造函数继承属性"></a>12.使用父类构造函数继承属性</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;<br>       // 子类继承父类属性的核心: 使用 call() 把父类的实例对象 this 手动修改为子类的实例对象 this<br>       // 父类 foo <br>       <span class="hljs-keyword">function</span> foo(name, age) &#123;<br>           this.name = name<br>           this.age = age<br>       &#125;<br>       // -------------------------------------------------------<br>       // 子类 fo <br>       <span class="hljs-keyword">function</span> fo(name, age, sex) &#123;<br>           // 把父类的实例对象 this 手动修改为子类的实例对象 this<br>           foo.call(this, name, age) //括号里的 this (也就是目标)指向的是 fo 的实例对象 这句代码是将 foo 中的 this 指向 fo 中的 this <br>               //属于子类自己的参数 sex<br>           this.sex = sex<br>       &#125;<br>       var w = new fo(<span class="hljs-string">&#x27;沈剑心&#x27;</span>, 18, <span class="hljs-string">&#x27;男&#x27;</span>)<br>       console.log(w);<br>   &lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="13-利用原型对象继承方法"><a href="#13-利用原型对象继承方法" class="headerlink" title="13.利用原型对象继承方法"></a>13.利用原型对象继承方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;<br>       //  子类继承父类上方法的核心: 新建一个对象作为子类的原型对象, 并把这个对象的原型指向父类的 prototype<br>       // 子类继承父类属性的核心: 使用 call() 把父类的实例对象 this 手动修改为子类的实例对象 this<br>       // 父类 foo <br>       <span class="hljs-keyword">function</span> foo(name, age) &#123;<br>           this.name = name<br>           this.age = age<br>       &#125;<br>       // 父类方法 <span class="hljs-built_in">set</span><br>       foo.prototype.set = <span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>               console.log(<span class="hljs-string">&#x27;hello&#x27;</span>);<br>           &#125;<br>           // -------------------------------------------------------<br>           // 子类 fo <br>       <span class="hljs-keyword">function</span> fo(name, age, sex) &#123;<br>           // 把父类的实例对象 this 手动修改为子类的实例对象 this<br>           foo.call(this, name, age) //括号里的 this (也就是目标)指向的是 fo 的实例对象 这句代码是将 foo 中的 this 指向 fo 中的 this <br>               //属于子类自己的参数 sex<br>           this.sex = sex<br>       &#125;<br>       // --------------------------------------------------------<br>       // 子类继承父类方法<br>       // 方法1(不推荐) 直接让子类 prototype 直接指向 父类 prototype<br>       // fo.prototype = foo.prototype //坏处 如果子类新添加了方法 那么父类也会有这个方法 <br>       // 方法2 新开辟一个空间 <br>       // var obj = &#123;<br>       //         constructor = fo, //把  constructor 重新指回 fo<br>       //         __proto__ = foo.prototype //通过原型链 把父构造函数的原型直接拿过来<br>       //     &#125;<br>       // 方法3 实例化父构造函数<br>       fo.prototype = new foo()<br>       fo.prototype.constructor = fo //指回 fo<br>           // ---------------------------------------------------------------<br>           // 子类新添加的方法 say<br>       fo.prototype.say = <span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>           console.log(<span class="hljs-string">&#x27;你好&#x27;</span>);<br>       &#125;<br>       var w = new fo(<span class="hljs-string">&#x27;沈剑心&#x27;</span>, 18, <span class="hljs-string">&#x27;男&#x27;</span>)<br>       w.set() //父类的方法<br>       w.say() //子类自己的方法<br>       console.log(foo.prototype); //父类上不会有子类自己的方法 say<br>       // console.log(w);<br>   &lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="14-类的本质"><a href="#14-类的本质" class="headerlink" title="14.类的本质"></a>14.类的本质</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;<br>       // es6 之前构造函数的特点:<br>       // 1. 构造函数默认有一个 prototype 属性, 它的值是一个对象<br>       // 2. 构造函数 prototype 属性下有 constructor 和 __proto__ 两个默认的属性<br>       // 3. 构造函数可以通过在 prototype 上添加方法, 去实现所有实例继承<br>       // 4. 构造函数创建的实例上 __proto__指向创建它构造函数的 prototype<br><br>       // class 类的本质其实就是一个改造版的构造函数<br>       class foo &#123;<br>           constructor(name, age) &#123;<br>                   this.name = name;<br>                   this.age = age<br>               &#125;<br>               // 类方法实际就放在 prototype 上 <br>           <span class="hljs-function"><span class="hljs-title">set</span></span>() &#123;<br>               console.log(<span class="hljs-string">&#x27;唱歌&#x27;</span>);<br>           &#125;<br>       &#125;<br>       // 类也支持在原型上去添加方法 实现继承或共享<br>       foo.prototype.eat = <span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>           console.log(<span class="hljs-string">&#x27;吃饭&#x27;</span>);<br>       &#125;<br>       console.log(foo.prototype); // 类的原型 prototype 属性下有 constructor 和 __proto__ 两个默认的属性<br>       var sjx = new foo(<span class="hljs-string">&#x27;沈剑心&#x27;</span>, 18)<br>       sjx.set() //原型上本来的方法<br>       sjx.eat() //实例对象可以继承原型上添加的方法<br>       console.log(sjx.__proto__ === foo.prototype); //实例对象的原型指向构造函数的原型<br>   &lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="15-ES5数组新增方法"><a href="#15-ES5数组新增方法" class="headerlink" title="15.ES5数组新增方法"></a>15.ES5数组新增方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;<br>        // 1. forEach() 方法可以快速地遍历数组<br>        // 参数：callback(元素, 索引, 数组本身)<br>        // 返回值：无<br>        // 例子: 使用 forEach 对数组求和<br>        // 但是 forEach() 方法并不能完全取代 <span class="hljs-keyword">for</span> 循环 比如 length-1 或者 i 每次 +=2 做不到<br>        var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]<br>        var sum = 0;<br>        var fhz = arr.forEach(<span class="hljs-keyword">function</span>(item, index, arr) &#123; //(元素, 索引, 数组本身)<br>            console.log(<span class="hljs-string">&#x27;索引号为: &#x27;</span> + index + <span class="hljs-string">&#x27; 的数组元素是: &#x27;</span> + item);<br>            console.log(arr); //数组本身<br>            sum += item //遍历数组求和<br>        &#125;)<br>        console.log(fhz); // 返回值：无 undefined<br>        console.log(sum); //和为 55<br><br>        // 2. filter() 方法从数组筛选出符合条件的一组元素<br>        // 参数：callback(元素, 索引, 数组本身)<br>        // 返回值：新数组<br>        // 例子: 使用 filter 筛选数组中所有偶数<br>        var arr2 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]<br>        var newArr = arr2.filter(<span class="hljs-keyword">function</span>(item, index) &#123; //(元素, 索引, 数组本身) 不要哪一个可以省略哪一个<br>            // 如果 <span class="hljs-built_in">return</span> 后面的结果为 <span class="hljs-literal">true</span> 就把当前项 <span class="hljs-built_in">return</span> 进新数组<br>            <span class="hljs-built_in">return</span> item % 2 == 0<br>        &#125;)<br>        console.log(newArr); //只有偶数的新数组<br>    &lt;/script&gt;<br><br>    --------------------------------------------------------------------------------------------------------------<br><br>     &lt;script&gt;<br>        // 1. some() 方法用于查找数组中是否有符合条件的某一个元素    有一个满足 就是 <span class="hljs-literal">true</span><br>        // 参数：callback(元素, 索引, 数组本身)<br>        // 返回值：<span class="hljs-literal">true</span>(找到) || <span class="hljs-literal">false</span>(找不到)<br>        // (1) 举例: 使用 some 方法判断数组里有没有大于 3 的数字<br>        var arr = [1, 2, 3]<br>        var <span class="hljs-built_in">set</span> = arr.some(<span class="hljs-keyword">function</span>(itme) &#123;<br>            <span class="hljs-built_in">return</span> itme &gt; 3 //<span class="hljs-literal">true</span>(找到) || <span class="hljs-literal">false</span>(找不到)<br>        &#125;)<br>        console.log(<span class="hljs-built_in">set</span>); //没有<br>        // ---------------------------------------------------------------------<br>        // (2) 举例: 使用 some 方法判断一组字符数组中是否有空字符串<br>        var arr2 = [<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;12&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;true&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>]<br>        var set2 = arr2.some(<span class="hljs-keyword">function</span>(itme) &#123;<br>            <span class="hljs-built_in">return</span> itme == <span class="hljs-string">&#x27;&#x27;</span> //<span class="hljs-literal">true</span>(找到) || <span class="hljs-literal">false</span>(找不到)<br>        &#125;)<br>        console.log(set2); //有<br>        // ------------------------------------------------------------------------------------------------------------<br>        // 2. every() 方法用于查找数组中是否所有的元素都符合条件    必须所有都满足 才为 <span class="hljs-literal">true</span><br>        // 参数：callback(元素, 索引, 数组本身)<br>        // 返回值：<span class="hljs-literal">true</span> || <span class="hljs-literal">false</span> (只要有一个不满足就返回 <span class="hljs-literal">false</span>)<br>        // 4. 举例: 使用 every 方法判断数组中是否所有数字都大于 20<br>        var arr3 = [30, 22, 45, 16, 20]<br>        var set3 = arr3.every(<span class="hljs-keyword">function</span>(itme) &#123;<br>            <span class="hljs-built_in">return</span> itme &gt; 20 //是否所有数字都大于 20 是就返回 <span class="hljs-literal">true</span> 有一个不大于 20 就会返回 <span class="hljs-literal">false</span><br>        &#125;)<br>        console.log(set3); //<span class="hljs-literal">false</span><br>    &lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="16-数组遍历方法"><a href="#16-数组遍历方法" class="headerlink" title="16.数组遍历方法"></a>16.数组遍历方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;<br>      // 4 种方法的共同点: 都会遍历数组 使用方法类似<br>      var arr = [1, 2, 3, 4, 5, 6];<br>      // 1. some() 方法判断数组中是否有唯一符合条件的元素, 遇到 <span class="hljs-built_in">return</span> <span class="hljs-literal">true</span> 会终止整个遍历<br>      var i = 0;<br>      var <span class="hljs-built_in">set</span> = arr.some(<span class="hljs-keyword">function</span>(itme) &#123;<br>          i++<br>          <span class="hljs-built_in">return</span> itme &gt; 3<br>      &#125;)<br>      console.log(<span class="hljs-built_in">set</span>);<br>      console.log(<span class="hljs-string">&#x27;在第&#x27;</span> + i + <span class="hljs-string">&#x27;次循环时遇到true终止遍历&#x27;</span>);<br><br>      // 2. forEach() 方法不会终止整个遍历(不管如何都会完整地遍历数组)<br>      var set2 = arr.forEach(<span class="hljs-keyword">function</span>(itme) &#123;<br>          console.log(<span class="hljs-string">&#x27;forEach方法不管如何都会完整地遍历数组&#x27;</span> + itme)<br>          <span class="hljs-built_in">return</span> <span class="hljs-literal">true</span> //无法终止循环<br>      &#125;);<br>      // 3. filter() 方法也不会终止整个遍历, 用来筛选符合条件的所有元素<br>      var set3 = arr.filter(<span class="hljs-keyword">function</span>(itme) &#123;<br>          console.log(<span class="hljs-string">&#x27;filter方法不管如何都会完整地遍历数组&#x27;</span> + itme)<br>          <span class="hljs-built_in">return</span> itme &gt; 3<br>      &#125;);<br>      // 4. every() 方法用于判断数组中是否所有的元素都符合条件, <span class="hljs-built_in">return</span> <span class="hljs-literal">false</span> 会终止整个遍历过程<br>      var j = 0<br>      var set4 = arr.every(<span class="hljs-keyword">function</span>(itme) &#123;<br>          j++<br>          <span class="hljs-built_in">return</span> itme &lt; 3<br>      &#125;);<br>      console.log(<span class="hljs-string">&#x27;在第&#x27;</span> + j + <span class="hljs-string">&#x27;次循环时遇到false终止遍历&#x27;</span>)<br>  &lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="17-字符串去除两边空格"><a href="#17-字符串去除两边空格" class="headerlink" title="17.字符串去除两边空格"></a>17.字符串去除两边空格</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;input <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;text&quot;</span>&gt; &lt;button&gt;提交&lt;/button&gt;<br>   &lt;script&gt;<br>       // 1. 使用 trim() 方法去除字符串两端的空格<br>       var str = <span class="hljs-string">&#x27;       1   123   1&#x27;</span><br>       str = str.trim(); //只会去除两边的 不会去除中间的<br>       console.log(str);<br><br>       // 2. 判断用户是否输入了有效的内容<br>       var btn = document.querySelector(<span class="hljs-string">&#x27;button&#x27;</span>)<br>       var ipt = document.querySelector(<span class="hljs-string">&#x27;input&#x27;</span>)<br>       btn.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>           // 获取有效内容<br>           <span class="hljs-keyword">if</span> (ipt.value.trim() == <span class="hljs-string">&#x27;&#x27;</span>) &#123; //判断去除两头空格之后的内容是否为空<br>               alert(<span class="hljs-string">&#x27;请输入正确的内容！！！！&#x27;</span>) //去了两头空格后还为空就弹他！！<br>           &#125;<br>       &#125;)<br>   &lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="18-Object-keys方法获取属性名"><a href="#18-Object-keys方法获取属性名" class="headerlink" title="18.Object.keys方法获取属性名"></a>18.Object.keys方法获取属性名</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;<br>       var obj = &#123;<br>           a: 1,<br>           b: 2,<br>           c: 3<br>       &#125;;<br>       // 1. 使用 Object.keys() 方法获取对象上所有的属性名<br>       var res = Object.keys(obj) //[<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>]<br>       console.log(res); // 返回值：所有属性名组成的数组<br><br>       // 2. 新遍历对象的方法<br>       res.forEach(<span class="hljs-keyword">function</span>(itme) &#123;<br>           console.log(itme); //这里的 itme 就是属性名<br>           console.log(obj[itme]); //属性值<br><br>       &#125;)<br>   &lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="19-Object-defineProperty方法"><a href="#19-Object-defineProperty方法" class="headerlink" title="19.Object.defineProperty方法"></a>19.Object.defineProperty方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs bash">一、Object.defineProperty() 方法的作用：[VUE 响应式的核心 2.x]<br>     在对象上定义一个新属性，或者修改原属性，并返回对象<br>   <br>   二、使用方法：<br>     Object.defineProperty(obj, prop, descriptor)<br>     (1) obj: 要定义属性的对象<br>     (2) prop: 要定义或修改的属性的名称, 字符串 <span class="hljs-string">&#x27;name&#x27;</span><br>     (3) descriptor: 要定义或修改的属性描述符, 数据格式是对象 &#123;&#125;<br><br>   三、属性的描述符<br>     (1) value: 属性值 <br>     (2) writable: 是否可以修改<br>     (3) enumerable: 是否可以枚举（遍历到）<br>     (4) configurable: 是否可以删除或再次修改特性<br>     三个属性描述符默认都是 <span class="hljs-literal">false</span> <br>     ------------实例---------------------------------------------------------------------<br>     &lt;script&gt;<br>       var obj = &#123;<br>           name: <span class="hljs-string">&#x27;沈剑心&#x27;</span>,<br>           age: 18,<br>           gender: <span class="hljs-string">&#x27;男&#x27;</span><br>       &#125;<br>       Object.defineProperty(obj, <span class="hljs-string">&#x27;height&#x27;</span>, &#123; //新增一个 height 属性<br>           value: <span class="hljs-string">&#x27;170&#x27;</span>, //属性值为 170<br>           writable: <span class="hljs-literal">false</span>, // 属性是否可以修改  <span class="hljs-literal">false</span>不可 <span class="hljs-literal">true</span> 可<br>           enumerable: <span class="hljs-literal">false</span>, //属性是否可以枚举（遍历到） <span class="hljs-literal">false</span>不可 <span class="hljs-literal">true</span> 可<br>           configurable: <span class="hljs-literal">false</span>, //属性是否可以删除或再次修改特性  <span class="hljs-literal">false</span>不可 <span class="hljs-literal">true</span> 可<br>       &#125;)<br>       obj.height = <span class="hljs-string">&#x27;180&#x27;</span> //修改不了<br>       console.log(Object.keys(obj)); //遍历不到<br>       delete obj.height //删除不了<br>       console.log(obj); // height 属性还在<br>   &lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="js高级第三天"><a href="#js高级第三天" class="headerlink" title="js高级第三天"></a>js高级第三天</h2><h3 id="1-函数定义"><a href="#1-函数定义" class="headerlink" title="1.函数定义"></a>1.函数定义</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">函数的定义方法： <br>    1. 函数声明<br>    2. 函数表达式<br>    3. 利用 Function 构造函数  <br><br>    &lt;script&gt;<br>      // 函数声明<br>      <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">foo</span></span>() &#123;<br>          console.log(<span class="hljs-string">&#x27;hello&#x27;</span>);<br>      &#125;<br>      foo();<br>      // 匿名函数表达式<br>      var <span class="hljs-built_in">set</span> = <span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>          console.log(<span class="hljs-string">&#x27;好好&#x27;</span>);<br>      &#125;<br>      <span class="hljs-built_in">set</span>();<br>      //第三种不常用 new Function() 使用构造函数<br>      var fn = new Function(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;console.log(a+b)&#x27;</span>)<br>      fn(1, 2)<br>  &lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="2-函数调用"><a href="#2-函数调用" class="headerlink" title="2.函数调用"></a>2.函数调用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;button&gt;按钮&lt;/button&gt;<br>   &lt;script&gt;<br>       // 函数的多种调用方式:<br>       // 1. 普通函数<br>       // 2. 对象中的函数调用<br>       // 3. 构造函数的调用<br>       // 4. 绑定事件的处理函数<br>       // 5. 定时器的处理函数 <br>       // 6. 立即执行函数<br>       // ----------------------------------- <br>       // 1.普通函数<br>       <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">fn1</span></span>() &#123;<br>           console.log(123);<br>       &#125;<br>       fn1();<br>       // 2. 对象中的函数调用<br>       var obj = &#123;<br>           say: <span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>               console.log(456);<br>           &#125;<br>       &#125;<br>       obj.say();<br>       // 3. 构造函数的调用 new 函数名 (参数)<br>       <span class="hljs-keyword">function</span> fn2(name, age) &#123;<br>           this.name = name<br>           this.age = age<br>       &#125;<br>       var w = new fn2(<span class="hljs-string">&#x27;沈剑心&#x27;</span>, 18)<br>       console.log(w);<br>       // 4. 绑定事件的处理函数<br>       var btn = document.querySelector(<span class="hljs-string">&#x27;button&#x27;</span>)<br>       btn.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>           console.log(<span class="hljs-string">&#x27;点击&#x27;</span>);<br>       &#125;);<br>       // 5. 定时器的处理函数 <br>       window.setInterval(<span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>           console.log(789);<br>       &#125;, 1000);<br>       // 6. 立即执行函数<br>       !(<span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>           console.log(<span class="hljs-string">&#x27;hi&#x27;</span>);<br>       &#125;)()<br>   &lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="3-函数内部的this指向"><a href="#3-函数内部的this指向" class="headerlink" title="3.函数内部的this指向"></a>3.函数内部的this指向</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;div&gt;hello&lt;/div&gt;<br>  &lt;script&gt;<br>      // 1.普通函数<br>      <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">fn1</span></span>() &#123;<br>          console.log(123);<br>      &#125;<br>      fn1();<br>      // 2. 对象中的函数调用<br>      var obj = &#123;<br>          say: <span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>              console.log(456);<br>          &#125;<br>      &#125;<br>      obj.say();<br>      // 3. 构造函数的调用 new 函数名 (参数)<br>      <span class="hljs-keyword">function</span> fn2(name, age) &#123;<br>          this.name = name<br>          this.age = age<br>      &#125;<br>      var w = new fn2(<span class="hljs-string">&#x27;沈剑心&#x27;</span>, 18)<br>      console.log(w);<br>      // 4. 绑定事件的处理函数<br>      var btn = document.querySelector(<span class="hljs-string">&#x27;button&#x27;</span>)<br>      btn.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>          console.log(<span class="hljs-string">&#x27;点击&#x27;</span>);<br>      &#125;);<br>      // 5. 定时器的处理函数 <br>      window.setInterval(<span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>          console.log(789);<br>      &#125;, 1000);<br>      // 6. 立即执行函数<br>      !(<span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>          console.log(<span class="hljs-string">&#x27;hi&#x27;</span>);<br>      &#125;)()<br>  &lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="4-call方法"><a href="#4-call方法" class="headerlink" title="4.call方法"></a>4.call方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bash">一、call 方法<br>  fn.call([thisArg, arg1, arg2...])<br>  作用：调用一个函数，并指定调用时 this 的值<br>  参数: thisArg 函数中 this 的指定值； arg1, arg2...可选的参数列表<br>  返回值：函数调用的结果<br><br>二、注意<br>  第一个参数 thisArg 如果不传或是 null、undefined，默认函数内 this 指向 window <br> <br>&lt;script&gt;<br>    <span class="hljs-keyword">function</span> fn(a) &#123;<br>        console.log(this);<br><br>    &#125;<br>    fn.call(&#123;<br>            name: <span class="hljs-string">&#x27;沈剑心&#x27;</span>,<br>            age: 18<br>        &#125;, 10)<br>        // call 方法继承父函数参数<br>    <span class="hljs-keyword">function</span> fn1(name, age) &#123;<br>        this.name = name<br>        this.age = age<br>    &#125;<br><br>    <span class="hljs-keyword">function</span> fn2(name, age) &#123;<br><br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="5-apply方法"><a href="#5-apply方法" class="headerlink" title="5.apply方法"></a>5.apply方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs bash">一、apply 方法<br>     fn.apply(thisArg[, argsArray])<br>     作用：调用一个函数，并指定调用时 this 的值<br>     参数: thisArg 函数中 this 的指定值； argsArray 可选的参数数组(!!)<br>     返回值：函数调用的结果<br><br>   二、apply 应用<br>     由于可以接受一个参数数组，所以对于数组元素的遍历操作可以使用 apply;<br>     在可以使用 call 的情况下， 都可以使用 apply 替代 <br><br>      &lt;script&gt;<br>       <span class="hljs-keyword">function</span> fn(a, b) &#123;<br>           console.log(this);<br>           console.log(a + b);<br><br>       &#125;<br>       fn.call(&#123;&#125;, 2, 3)<br>           // 使用 apply 去改变 this 指向<br>       fn.apply(&#123;&#125;, [2, 3])<br>           // 1,使用 appLy 判断一组数的最大值<br>       console.log(Math.max(1, 2, 3, 5, 6, 7));<br><br><br>       var arr = [1, 3, 4, 5, 6, 77, 1]<br>           // 使用 null 作为 第一个参数 表示不关心  this 指向，默认为 window<br>           // opply 可以把第二个参数 数组 转成逗号分隔的参数进行传递<br>       var res = Math.max.apply(null, arr)<br>       console.log(res);<br>   &lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="6-bind方法"><a href="#6-bind方法" class="headerlink" title="6.bind方法"></a>6.bind方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">一、<span class="hljs-built_in">bind</span> 方法<br>    var newFn = fn.bind(thisArg[, arg1, arg2, ...])<br>    作用：基于原函数创建一个新函数，这个新函数的 this 被指定为第一个参数， 其余参数作为实参传递给新函数<br>    参数：thisArg 是新函数内 this 的预设值; arg1, arg2 是新函数预设传入的参数<br>    返回值: 新函数<br><br>  二、<span class="hljs-built_in">bind</span> 作用<br>    (1) 创建一个函数，不论怎么调用，这个函数都有同样的 this 值<br>    (2) 使一个函数拥有预设的初始参数 <br><br>     &lt;script&gt;<br>      <span class="hljs-keyword">function</span> fn(a, b) &#123;<br>          console.log(this); //指向 window<br>          console.log(a + b);<br>      &#125;<br>      // <span class="hljs-built_in">bind</span> 是用来创建新函数的 并且可以为新函数 预先指定传入的实参<br>      //好处 可以让一个 this 无论怎么调用 都是指向一个人<br>      var newFn = fn.bind(&#123;&#125;, 3, 4)<br>      newFn(); //新函数的 tihs 已经被修改为 &#123;&#125;<br>      fn(3, 4) //调用 fn 传入参数<br>  &lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="7-bind方法的应用"><a href="#7-bind方法的应用" class="headerlink" title="7.bind方法的应用"></a>7.bind方法的应用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;button&gt;按钮&lt;/button&gt;<br>   &lt;script&gt;<br>       // 为定时器中的函数修改 this 指向：点击按钮后禁用这个按钮，3s后再开启 <br>       var btn = document.querySelector(<span class="hljs-string">&#x27;button&#x27;</span>)<br>       btn.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>               this.disabled = <span class="hljs-literal">true</span> //禁用按钮<br>               console.log(this); //指向 btn<br>               setInterval(<span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>                       console.log(this);<br>                       // 2s后再开启<br>                       this.disabled = <span class="hljs-literal">false</span> //解除禁用<br>                   &#125;.<span class="hljs-built_in">bind</span>(this), 2000) //.<span class="hljs-built_in">bind</span>(this), 2000)//这个 this是当做参数传递的 不在定时器里面在点击事件里面 所以指向的是 btn <br>           &#125;) //直接写 .<span class="hljs-built_in">bind</span>(btn), 2000) 即可<br>   &lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="8-严格模式"><a href="#8-严格模式" class="headerlink" title="8.严格模式"></a>8.严格模式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">一、什么是严格模式 （了解）<br>    采用具有限制性JavaScript变体的一种方式，摆脱了以前的松散模式<br>    1. 消除了 js 代码的不合理和不严谨地方，减少怪异行为<br>    2. 消除了代码的不安全地方，保证代码安全运行<br>    3. 提高编译器的效率，增加运行的速度<br>    4. 禁用 ECMAScript 未来版本中可能会定义的一些语法 class extends super 等<br><br>  二、严格模式的应用<br>    1. 为整个 js 文件开启严格模式, 即在代码开头添加 <span class="hljs-string">&#x27;use strict&#x27;</span>;<br>    2. 为某个函数开启严格模式, 即函数体代码开头添加 <span class="hljs-string">&#x27;use strict&#x27;</span>; <br><br>      &lt;script&gt;<br>      <span class="hljs-string">&#x27;use strict&#x27;</span>; //表示整个 script 里面的所有代码都按照严格模式来运行<br>      <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">fn</span></span>() &#123;<br>          <span class="hljs-string">&#x27;use strict&#x27;</span>; //表示 在 fn 函数中的所有代码都按照严格模式来运行 fn 函数外的不做限制<br>      &#125;<br>  &lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="9-严格模式中的变化"><a href="#9-严格模式中的变化" class="headerlink" title="9.严格模式中的变化"></a>9.严格模式中的变化</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;<br>       <span class="hljs-string">&#x27;use strict&#x27;</span>;<br><br>       // 1. 变量未声明不能直接赋值<br>       // num = 10;<br>       // console.log(num);<br><br>       // 2. 变量必须先声明再使用(同1)<br><br>       // 4. 函数内的 this 默认指向 undefined<br>       // <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">foo</span></span>() &#123;<br>       //     console.log(this);<br><br>       // &#125;<br>       // foo();<br>       // 5. 非函数内的 this 默认指向 undefined 浏览器不同结果不同 俺滴谷歌就还是指向 window<br>       // console.log(this);<br><br>       // 6. 构造函数和类只能加 new 进行使用   直接报错<br>       // <span class="hljs-keyword">function</span> fn(a, b, c) &#123; <br>       //     this.a<br>       //     this.b<br>       //     this.c<br>       //     console.log(a + b + c);<br><br>       // &#125;<br>       // var w = fn(1, 2, 3)<br>       // console.log(w);<br><br>       // 7. 函数中的参数名不能重名 <br>       // <span class="hljs-keyword">function</span> fo1(a, a) &#123;<br>       // console.log(a + b);<br>       // &#125;<br>       // fo1(1, 2);<br><br>       // 8. 不允许在非函数的代码块内声明函数 (chrome 浏览器没有实现)<br>       <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>           <span class="hljs-keyword">function</span> fo2(a, b) &#123;<br>               console.log(a + b);<br>           &#125;<br>       &#125;<br>       fo2(1, 2);<br>   &lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="10-高阶函数"><a href="#10-高阶函数" class="headerlink" title="10.高阶函数"></a>10.高阶函数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash">高阶函数是对其他函数进行操作的函数，主要有两种类型的高阶函数：<br>     1. 把函数作为参数的函数<br>     2. 把函数作为返回值的函数 <br><br>        &lt;script&gt;<br>       // 1. 把函数作为参数的函数<br>       <span class="hljs-keyword">function</span> Foo(callback) &#123;<br>           setTimeout(<span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>               callback()<br>           &#125;, 1000)<br>       &#125;<br>       Foo(<span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>           console.log(123);<br>       &#125;);<br>       // 2. 把函数作为返回值的函数<br>       <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">fn</span></span>() &#123;<br>           <span class="hljs-built_in">return</span> <span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>               console.log(<span class="hljs-string">&#x27;hello&#x27;</span>);<br><br>           &#125;<br>       &#125;<br>       // 把这个 fn 函数赋值给 res  那么在调用这个函数时 就可以直接变量名加小括号<br>       var res = fn()<br>       console.log(res);<br>       // 变量名 res 加小括号 调用 fn 函数<br>       res()<br>   &lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="11-闭包"><a href="#11-闭包" class="headerlink" title="11.闭包"></a>11.闭包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs bash">一、闭包的概念 <br>    内部函数访问外部函数声明的变量，这种组合方式就是闭包<br><br>  二、JS 中的垃圾回收机制(GC)<br>    垃圾回收机制会定期（周期性）找出那些不再引用到的内存（变量），然后释放其内存<br><br>  三、闭包产生的原因<br>   (1) 当一个函数内的声明的变量没有被其他函数引用时，那么调用完这个函数后，<br>    所有的局部变量就会被垃圾回收机制清除；<br>   (2) 一旦这个变量被另外一个函数所引用，这个变量的值会始终保存在内存中，<br>    不会被垃圾回收机制回收，从而形成了闭包 <br><br>     &lt;script&gt;<br>      // 外部函数<br>      <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">foo</span></span>() &#123;<br>          var num = 10<br>              // 内部函数<br>          <span class="hljs-built_in">return</span> <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">bar</span></span>() &#123; //<span class="hljs-built_in">return</span> 返回内部函数 bar<br>              console.log(++num); //内部访问 外部函数的变量 num<br><br>          &#125;<br>      &#125;<br>      // 把这个 foo 函数赋值给 res  那么在调用这个函数时 就可以直接变量名加小括号<br>      var res = foo() //调用函数 foo 并用全局变量 res 接收 foo 的返回值(内部函数 bar)<br>      console.log(res); //内部函数 bar<br>      // 调用 foo 这个函数 直接 变量名加小括号<br>      res() //调用 foo 输出返回值 bar 函数  bar 的函数返回值为  console.log(++num);  所以最终打印 ++num 的值<br>          // 返回的这个 bar 这个函数被全局的 res 所引用， 所以 bar 不会被删除 由于 bar  函数中 引用了 num 这个变量<br>          // 所以 num 这个变量在 foo 调用完后也不会被删除<br>      res()<br>  &lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="12-闭包的作用"><a href="#12-闭包的作用" class="headerlink" title="12.闭包的作用"></a>12.闭包的作用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs bash">一、闭包的作用<br>    （1）延伸了变量的使用范围<br>    （2）实现了数据的封装<br>    （3）实现了数据的缓存（函数的柯里化）<br><br>  二、闭包的缺点 (了解)<br>    (1) 闭包会使得函数中的变量都被保存在内存中，加大了内存消耗 (空间换时间)<br>    (2) 容器引发内存泄漏 (内存没有及时清理)<br><br>     &lt;script&gt;<br>      // 案例1:<br>      // <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">foo</span></span> () &#123;<br>      //   var num = 10<br>      //   <span class="hljs-built_in">return</span> <span class="hljs-function"><span class="hljs-title">function</span></span> () &#123;<br>      //     console.log(++num)  <br>      //   &#125;<br>      // &#125;<br><br>      // var res = foo()<br>      // res()<br>      // res()<br><br>      // 案例2:<br>      <span class="hljs-keyword">function</span> makeAdd(x) &#123; // 局部变量  注意 形参也可以看做是外部函数声明的变量 他被内部函数所引用，也不会被销毁 一直保持着<br>          <span class="hljs-built_in">return</span> <span class="hljs-keyword">function</span>(y) &#123;<br>              <span class="hljs-built_in">return</span> x + y<br>          &#125;<br>      &#125;<br>      // console.log(x)<br><br>      var add5 = makeAdd(5)<br>      var add10 = makeAdd(10)<br><br>      console.log(add5(2))<br>      console.log(add10(2))<br>  &lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="13-点击li打印当前的索引"><a href="#13-点击li打印当前的索引" class="headerlink" title="13.点击li打印当前的索引"></a>13.点击li打印当前的索引</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;button&gt;按钮&lt;/button&gt;<br>   &lt;button&gt;按钮&lt;/button&gt;<br>   &lt;button&gt;按钮&lt;/button&gt;<br>   &lt;button&gt;按钮&lt;/button&gt;<br>   &lt;button&gt;按钮&lt;/button&gt;<br><br>   &lt;script&gt;<br>       // // 需求: 点击每个按钮弹出当前按钮的索引 优点: 简单 高效 快捷    缺点:不招面试官待见 非叫人用闭包！！！！！！！！！！！！！！<br>       var btn = document.querySelectorAll(<span class="hljs-string">&#x27;button&#x27;</span>);<br>       // // 方法1 利用自定义属性的方法 给每一个按钮添加一个索引<br>       // <span class="hljs-keyword">for</span> (var i = 0; i &lt; btn.length; i++) &#123;<br>       //     btn[i].index = i //给每一个按钮 btn[i] 添加一个自定义属性 index 属性值为循环计数变量 i <br>       //     btn[i].addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-title">function</span></span>() &#123; //给每一个按钮绑定点击事件<br>       //         console.log(this.index); //打印输出当前点击的按钮 this 的 index属性值(也就是索引)<br>       //     &#125;)<br>       // &#125;<br>       // 方法2 闭包的应用: 在异步任务中使用同步任务下的变量 优点:刁钻的面试官的最爱！！！  缺点 ：太复杂 占内存<br>       <span class="hljs-keyword">for</span> (var i = 0; i &lt; btn.length; i++) &#123; //开启循环 <br>           // 每一次循环都创建一个立即执行函数 使用立即执行函数形成的闭包 叫做小闭包<br>           // 这个 j 就是形参 保存每一次的 i 每一次循环都会立即执行函数 开辟内存保存 <br>           !(<span class="hljs-keyword">function</span>(j) &#123; //每一次循环 都创建了一个立即执行函数<br>               // 比如第一次循环 创建一个立即执行函数 i 为 0  立即执行函数会把 当前的 i(0) 当做实参传入 此时 形参j 就等于 0 然后函数内部 给btn[j]绑定事件<br>               // 也就是给索引为 j(0) 的按钮 绑定了事件 这个事件里所打印的 就是当前的 形参 j 的值 下一次循环再开辟新的空间 创建新的函数<br>               // 第二次循环 又创建一个立即执行函数 i 为 1 立即执行函数会把 当前的 i(1) 当做实参传入 此时 形参j 就等于 1 然后函数内部 给btn[j]绑定事件 依次循环<br>               // 立即执行函数的 j 因为内部有引用 所以不会消除<br>               // 所以就意味着有几次循环 就有几个立即执行函数 每一个立即执行函数里面都有一个 j  值不同<br>               // 每一次循环都会给当前 j 号的按钮绑定一个点击事件 下一次循环会创建新的空间 所以这个会一直保留 每一个按钮里面的 j 也就不相同<br>               btn[j].addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>                   console.log(j);<br>                   // 这里的 j 指的就是当前按钮的  btn[j] 里面的 j 也就是当前传入的参数 j(i) <br>                   // 比如点击第一个按钮 就是触发了给 0 号按钮绑定的点击事件 这里所保存的 j 就是 0 <br>                   // 点击第几个按钮 就是触发了给 第几号 按钮绑定的点击事件 这里所保存的 j 就是 几 <br>               &#125;)<br>           &#125;)(i) //将每一次循环的 i 当做实参传入<br>       &#125;<br>   &lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="14-3秒之后打印li的内容"><a href="#14-3秒之后打印li的内容" class="headerlink" title="14.3秒之后打印li的内容"></a>14.3秒之后打印li的内容</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;ol&gt;<br>      &lt;li&gt;hello1&lt;/li&gt;<br>      &lt;li&gt;hello2&lt;/li&gt;<br>      &lt;li&gt;hello3&lt;/li&gt;<br>  &lt;/ol&gt;<br>  &lt;script&gt;<br>      // 需求: 3s 之后打印每个 li 中的内容<br>      var lis = document.querySelectorAll(<span class="hljs-string">&#x27;li&#x27;</span>)<br>          // 遍历 lis <br>      <span class="hljs-keyword">for</span> (var i = 0; i &lt; lis.length; i++) &#123;<br>          //立即执行函数<br>          !(<span class="hljs-keyword">function</span>(j) &#123; //形参接收 每一个 i 并保存<br>              setTimeout(<span class="hljs-function"><span class="hljs-title">function</span></span>() &#123; //开启定时器<br>                  console.log(lis[j].innerHTML); //每一次执行函数时 把当前的 j 也就是 lis 里的内容打印出来<br>              &#125;, 3000)<br>          &#125;)(i) //传入实参 i<br>      &#125;<br>  &lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="15-计算打车的价格"><a href="#15-计算打车的价格" class="headerlink" title="15.计算打车的价格"></a>15.计算打车的价格</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;<br>       // 闭包的应用：计算打车的价格 <br>       /* 打车起步价 8（3公里内），之后每多一公里增加 5 块钱，用户输入公里数就可以得出打车价格<br>       如果有拥堵的情况，在之前价格的基础上再多收取 10 块钱拥堵费 */<br><br>       // 封装一个求正常时打车价格 和 拥挤时打车价格的对象, 并全局中不能访问到起步价和总价 <br>       var obj = (<span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>           var total = 0; //打车费<br>           var strrt = 8; //起步价<br>           <span class="hljs-built_in">return</span> &#123;<br>               // 正常时打车价格<br>               price: <span class="hljs-keyword">function</span>(km1) &#123; // km1 接收一个实参 也就是走了多少公里<br>                   // 如果公里数 (也就是传入的实参)小于等于3 (没有超过三公里) 就返回起步价 <br>                   // 否则就返回每超出一公里的价格 <br>                   // km1 - 3 实际走的公里数 km1 减去 起步的3公里 就是我超出了多少公里 超出一公里加5块 那么就拿超出的总公里数乘以5<br>                   // 最后加上起步价 8 块 就是总钱数<br>                   total = km1 &lt;= 3 ? strrt : (km1 - 3) * 5 + strrt<br>                   <span class="hljs-built_in">return</span> total<br>               &#125;,<br>               // 拥堵时打车价格<br>               busyPrice: <span class="hljs-keyword">function</span>(km2) &#123; //形参接收一个布尔值<br>                   // 三元表达式判断当前的形参值是 <span class="hljs-literal">true</span> 还是 <span class="hljs-literal">false</span> <br>                   // 如果是 <span class="hljs-literal">true</span> 执行左边 代表堵车 在原来车费 total 的基础上加10块 <span class="hljs-literal">false</span> 代表不堵车 执行右边 直接返回原车费 total<br>                   <span class="hljs-built_in">return</span> km2 ? total + 10 : total<br>               &#125;<br>           &#125;<br>       &#125;)()<br>       console.log(obj.price(10));<br>       // console.log(obj.busyPrice(5));<br>       console.log(obj.busyPrice(<span class="hljs-literal">true</span>));<br>   &lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="16-递归函数"><a href="#16-递归函数" class="headerlink" title="16.递归函数"></a>16.递归函数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs bash">一、递归函数<br>    函数内部自己调用自己，作用和循环效果类似 <br><br>  二、递归的注意事项<br>    递归很容易发生 “栈溢出” 错误，所以和 <span class="hljs-keyword">while</span> 循环类似必须要添加中断条件 <br><br>        &lt;script&gt;<br>      // 递归: 函数内部自己调用自己<br>      // var num = 0<br><br>      // <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">foo</span></span>() &#123;<br>      //     num++<br>      //     console.log(num);<br>      //     foo()<br><br>      // &#125;<br>      // foo();<br>      // 要打印 6 句话 hello<br>      var num1 = 0<br>          // 注意！！！！！！！！！！！！！！！！！！！！递归函数必须添加中断条件<br>      <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">fn</span></span>() &#123;<br>          num1++<br>          <span class="hljs-keyword">if</span> (num1 &gt; 6) &#123; //利用判断来中断递归函数<br>              <span class="hljs-built_in">return</span> //断！断！断！！！<br>          &#125;<br>          console.log(<span class="hljs-string">&#x27;hello&#x27;</span>);<br><br>          fn()<br>      &#125;<br>      fn()<br>  &lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="17-利用递归求阶乘"><a href="#17-利用递归求阶乘" class="headerlink" title="17.利用递归求阶乘"></a>17.利用递归求阶乘</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;<br>      // 需求：利用递归求数学题 （找规律） <br>      // 1. 求 1 * 2 * 3 * 4 * ... * n 阶乘（乘积）<br><br>      // <span class="hljs-keyword">function</span> fn(n) &#123;<br>      //     <span class="hljs-keyword">if</span> (n == 1) &#123; //终止条件 当 n == 1<br>      //         <span class="hljs-built_in">return</span> 1<br>      //     &#125;<br>      //     // 通常的规律是 n * n-1 其中 n-1 是动态改变的<br>      //     <span class="hljs-built_in">return</span> n * fn(n - 1) // n-1 代表从最后一位依次往前计算<br>      // &#125;<br>      // var res = fn(4)<br>      // console.log(res);<br>      // 4 * fn(3)<br>      // 4 * 3 * fn(2)<br>      // 4 * 3 * 2 * fn(1)<br>      // 4 * 3 * 2 * 1<br>      // ---------------------------------------------------------------------------------------------<br>      // 2. 求 n 到 m 两个数之间的阶乘  5, 10 ===&gt; 5 * 6 * ... * 10<br><br>      <span class="hljs-keyword">function</span> fn2(n, m) &#123;<br>          <span class="hljs-keyword">if</span> (m == n) &#123; //当最后一位等于第一位时 就说明遍历到头了<br>              <span class="hljs-built_in">return</span> m<br>          &#125;<br>          <span class="hljs-built_in">return</span> m * fn2(n, m - 1) //两个参数 所以要传入两个不能省略 n代表开始数字 m 代表结束数字  m-1 就是从后往前依次计数<br>      &#125;<br>      var res2 = fn2(5, 10)<br>      console.log(res2);<br>  &lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="18-利用递归求斐波那契数列"><a href="#18-利用递归求斐波那契数列" class="headerlink" title="18.利用递归求斐波那契数列"></a>18.利用递归求斐波那契数列</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;<br>       // 2. 利用递归函数求斐波那契数列（兔子序列） 1, 1, 2, 3, 5, 8, 13, 21...<br>       // 用户输入一个数字 n 就可以求出这个数字对应的斐波那契数列值  <br>       <span class="hljs-keyword">function</span> fn(n) &#123;<br>           // 终止条件<br>           <span class="hljs-keyword">if</span> (n == 0) <span class="hljs-built_in">return</span> 0<br>           <span class="hljs-keyword">if</span> (n == 1) <span class="hljs-built_in">return</span> 1<br>               // 通用规律<br>           <span class="hljs-built_in">return</span> fn(n - 1) + fn(n - 2)<br>               // 简便的写法<br>               // <span class="hljs-built_in">return</span> n == 0 || n == 1 ? n : fn(n - 1) + fn(n - 2)<br>       &#125;<br>       console.log(fn(4));<br>   &lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="19-利用递归遍历数据"><a href="#19-利用递归遍历数据" class="headerlink" title="19.利用递归遍历数据"></a>19.利用递归遍历数据</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;<br>       // 递归应用：根据 id 号返回对应的数据对象<br>       var data = [&#123;<br>           id: 1,<br>           name: <span class="hljs-string">&#x27;家电&#x27;</span>,<br>           goods: [&#123;<br>               id: 11,<br>               gname: <span class="hljs-string">&#x27;冰箱&#x27;</span>,<br>               goods: [&#123;<br>                   id: 13,<br>                   gname: <span class="hljs-string">&#x27;海尔冰箱&#x27;</span><br>               &#125;]<br>           &#125;, &#123;<br>               id: 12,<br>               gname: <span class="hljs-string">&#x27;洗衣机&#x27;</span><br>           &#125;]<br>       &#125;, &#123;<br>           id: 2,<br>           name: <span class="hljs-string">&#x27;服饰&#x27;</span><br>       &#125;, &#123;<br>           id: 3,<br>           name: <span class="hljs-string">&#x27;鞋包&#x27;</span>,<br>           goods: [&#123;<br>               id: 33,<br>               name: <span class="hljs-string">&#x27;耐克&#x27;</span><br>           &#125;]<br>       &#125;]<br><br><br>       // 写出递归函数： 要求输入 id 号，就可以返回对应的数据对象 (难点：数据格式是多层嵌套的) <br>       // arr 要找的商品对象   id  要查找的 id<br>       var res = null<br><br>       <span class="hljs-keyword">function</span> getGood(arr, id) &#123;<br>           arr.forEach(<span class="hljs-keyword">function</span>(item, index) &#123; //遍历<br>               // 判断当前遍历到的商品对象，他的 id 值是否和传入的实参(id) 一致<br>               // 如果要找 name 就是 item.name <br>               <span class="hljs-keyword">if</span> (item.id == id) &#123; //当前元素的id 是否与 传入的实参 (id) 一致<br>                   res = item; // 如果一致 将当前的元素赋值给 res<br>                   //判断当前商品是否有 2 级分类 也就是下面有没有 goods 没有就不用找了  并且 res 为 null (也就是没有这个商品再去找)<br>                   //如果res 变量不为 null 说明之前已经找到了 如果只判断有没有 goods 的话会有问题 <br>                   //因为一旦出现两个 goods 那么之前已经找到的商品 res 值就会被后面的 goods 的值覆盖 所以要两条判断<br>                   // 判断 首先有没有要找的二级分类 并且 res 有没有值 有值代表已经找到正确的了 再遇见同名的二级分类也不会进入 这样就不会覆盖正确的商品<br>               &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (item.goods &amp;&amp; res == null) &#123;<br>                   res = getGood(item.goods, id) //如果有就再次调用 getGood 函数传入当前元素的goods 和实参 id 去递归查找<br>               &#125;<br>           &#125;)<br>           <span class="hljs-built_in">return</span> res<br>       &#125;<br>       var res = getGood(data, 13)<br>       console.log(res);<br>   &lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="20-浅拷贝"><a href="#20-浅拷贝" class="headerlink" title="20.浅拷贝"></a>20.浅拷贝</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>  只拷贝对象一层的数据，复杂数据类型只拷贝内存地址值（引用同一个对象） <br><br>    &lt;script&gt;<br>    var obj = &#123;<br>        id: 1,<br>        name: <span class="hljs-string">&#x27;小明&#x27;</span>,<br>        data: &#123;<br>            id: 2,<br>            age: 19<br>        &#125;<br>    &#125;<br><br>    var obj2 = &#123;&#125;<br><br>    <span class="hljs-keyword">for</span> (var key <span class="hljs-keyword">in</span> obj) &#123;<br>        //把 obj 里面的内容 拷贝一份到 obj2<br>        obj2[key] = obj[key] //注意 对象属于复杂数据类型 只能拷贝地址值 一旦修改 就意味着 地址值指向的堆内存的内容修改了<br>    &#125;<br>    console.log(obj);<br>    console.log(obj2);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="21-深拷贝"><a href="#21-深拷贝" class="headerlink" title="21.深拷贝"></a>21.深拷贝</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;!-- 一、深拷贝 拷贝对象多层的数据，遇到复杂数据类型会继续新建一个空间，拷贝里面每一层的属性和值<br>    二、和浅拷贝的区别 深拷贝后的对象和原对象是完全隔离的，各自互不影响， 而浅拷贝中所有复杂数据类型的值，都是共同引用的 --&gt;<br>  &lt;script&gt;<br>      var obj1 = &#123;<br>          id: 1,<br>          name: <span class="hljs-string">&#x27;小明&#x27;</span>,<br>          data: &#123;<br>              id: 2,<br>              age: 19,<br>              goods: &#123;<br>                  id: 10<br>              &#125;<br>          &#125;,<br>          arr: [1, 2, 3]<br>      &#125;<br><br>      var obj2 = &#123;&#125; //定义一个要接收的空对象 obj2<br><br>      <span class="hljs-keyword">function</span> deepClone(obj1, obj2) &#123;<br>          <span class="hljs-keyword">for</span> (var key <span class="hljs-keyword">in</span> obj1) &#123; //遍历对象 obj1 数组也支持 <span class="hljs-keyword">for</span> <span class="hljs-keyword">in</span> 遍历<br>              var temp = obj1[key] //遍历到的对象拷贝给 temp<br>                  // 2,分3种情况判断  注意 先判断数组 在判断对象 因为对象也包含数组<br>              <span class="hljs-keyword">if</span> (Array.isArray(temp)) &#123; //判断是否是数组   Array.isArray(要进行判断的元素)<br>                  obj2[key] = [] //能够进入这一行 代表此时 temp 是数组 如果是数组 那么先创建一个空数组<br>                  deepClone(temp, obj2[key]) //然后传入参数1 老数组 temp  参数2 空数组obj[key] 继续进入函数deepClone去依次遍历 判断 拷贝<br>              &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (temp instanceof Object) &#123; //判断是否是对象   要进行判断的元素 instanceof Object<br>                  obj2[key] = &#123;&#125; //能够进入这一行 代表此时 temp 是对象 如果是对象 那么进入此代码 先创建一个空对象<br>                  deepClone(temp, obj2[key]) //然后调用 deepClone 函数 传入参数 同数组<br>              &#125; <span class="hljs-keyword">else</span> &#123; //如果是简单数据类型 则直接拷贝进 obj2<br>                  obj2[key] = temp<br>              &#125;<br>          &#125;<br>      &#125;<br>      deepClone(obj1, obj2) //调用函数 deepClone 传入参数 obj1, obj2<br>      obj2.id = 10 //这里修改obj2 就不会影响到 obj1<br>      console.log(obj1);<br>      console.log(obj2);<br>  &lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="22-快速深拷贝与浅拷贝"><a href="#22-快速深拷贝与浅拷贝" class="headerlink" title="22.快速深拷贝与浅拷贝"></a>22.快速深拷贝与浅拷贝</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;<br>       var obj = &#123;<br>           a: 1,<br>           b: 2,<br>           c: 3,<br>           d: &#123;<br>               e: 4<br>           &#125;<br>       &#125;;<br>       // 快速浅拷贝<br>       var abj = &#123;...obj //把 obj 浅拷贝给 abj<br>       &#125;;<br>       console.log(abj);<br>       // 快速深拷贝<br>       // JSON.stringify() 可以把复杂数据类型转成字符串<br>       // JSON.parse() 可以把字符串转成复杂数据类型<br>       var obj2 = JSON.parse(JSON.stringify(obj)) //把 obj 深拷贝给 obj2<br>       obj.d.e = 10 //深拷贝 obj 修改不会影响 obj2<br>       console.log(obj2);<br>   &lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="23-代码分析"><a href="#23-代码分析" class="headerlink" title="23.代码分析"></a>23.代码分析</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;<br>        // 案例1: <br>        // var name = <span class="hljs-string">&#x27;the window&#x27;</span><br>        // var obj = &#123;<br>        //   name: <span class="hljs-string">&#x27;My project&#x27;</span>,<br>        //   getNameFunc: <span class="hljs-function"><span class="hljs-title">function</span></span> () &#123;<br>        //     <span class="hljs-built_in">return</span> <span class="hljs-function"><span class="hljs-title">function</span></span> () &#123;<br>        //      tihs指向window<br>        //       <span class="hljs-built_in">return</span> this.name<br>        //     &#125;<br>        //   &#125;<br>        // &#125;<br><br>        // console.log(obj.getNameFunc()()) <br><br>        // 案例2:<br>        var name = <span class="hljs-string">&#x27;the window&#x27;</span><br>        var obj = &#123;<br>            name: <span class="hljs-string">&#x27;My project&#x27;</span>,<br>            getNameFunc: <span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>                var that = this<br>                <span class="hljs-built_in">return</span> <span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>                    <span class="hljs-built_in">return</span> that.name<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        console.log(obj.getNameFunc()())<br>    &lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="js高级第四天"><a href="#js高级第四天" class="headerlink" title="js高级第四天"></a>js高级第四天</h2><h3 id="1-正则表达式"><a href="#1-正则表达式" class="headerlink" title="1.正则表达式"></a>1.正则表达式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">一、正则表达式（Regular Expression）<br>     是用于匹配字符串中字符组合的模式，在数据类型中是属于对象<br><br>   二、正则表达式的作用<br>     正则表达式通常用来校验、查找、替换指定规则的字符文本<br><br>     1. 验证表单，如：只能输入英文、字母、数字和下划线<br>     2. 过滤页面内容中的敏感词汇，或者对指定字符组合进行替换 <br>     3. 从字符串中提取我们想要的特定部分<br><br>   三、正则表达式的特点<br>     1. 灵活性、逻辑性和功能性 （强大）<br>     2. 简单高效<br>     3. 可读性稍差，不便于记忆（一般复制相关的正则表达式，修改后即可使用）<br><br></code></pre></td></tr></table></figure><h3 id="2-正则表达式的使用"><a href="#2-正则表达式的使用" class="headerlink" title="2.正则表达式的使用"></a>2.正则表达式的使用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;<br>       // 使用正则表达式判断字符串中是否包含 abc 字符<br>       // 1.1 方法1 构造函数方式 RegExp，创建正则表达式 <br>       var rg1 = RegExp = /abc/<br>       rg1.test(<span class="hljs-string">&#x27;abc&#x27;</span>) //拿创建的正则表达式 rg1 去判断 内容 rg1.test(<span class="hljs-string">&#x27;abc&#x27;</span>)  如果括号里的内容符合正则表达式的要求 则返回 <span class="hljs-literal">true</span> 否则返回 <span class="hljs-literal">false</span><br>       console.log(rg1.test(<span class="hljs-string">&#x27;abc&#x27;</span>)); //<span class="hljs-literal">true</span><br>       console.log(rg1.test(<span class="hljs-string">&#x27;bc&#x27;</span>)); //<span class="hljs-literal">false</span><br>       console.log(rg1.test(<span class="hljs-string">&#x27;abcabc&#x27;</span>)); //<span class="hljs-literal">true</span><br>       console.log(rg1.test(<span class="hljs-string">&#x27;a2bcarbwc&#x27;</span>)); //<span class="hljs-literal">false</span><br>       console.log(<span class="hljs-string">&#x27;-------------------------------------&#x27;</span>);<br>       // 1.2 方法2 常用 字面量方式创建正则表达式 /表达式/<br>       var rg2 = /abc/;<br>       // 1.3 正则表达式的 <span class="hljs-built_in">test</span> 方法，检测字符串是否符合正则表达式定义的规则，返回 <span class="hljs-literal">true</span> 或 <span class="hljs-literal">false</span><br>       // 语法： reg.test(str)<br>       console.log(rg2.test(<span class="hljs-string">&#x27;abc&#x27;</span>)); //<span class="hljs-literal">true</span><br>       console.log(rg2.test(<span class="hljs-string">&#x27;qwe&#x27;</span>)); //不包含 abc 所以是 <span class="hljs-literal">false</span><br>       console.log(rg2.test(<span class="hljs-string">&#x27;awwbeqc&#x27;</span>)); //包含 abc 但是被其他字符隔开了 所以是 <span class="hljs-literal">false</span><br>       console.log(rg2.test(<span class="hljs-string">&#x27;abeabcqc&#x27;</span>)); //包含 abc 并且有连在一起的 abc  所以是 <span class="hljs-literal">true</span><br>   &lt;/script&gt;<br><br></code></pre></td></tr></table></figure><h3 id="3-边界符"><a href="#3-边界符" class="headerlink" title="3.边界符"></a>3.边界符</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs bash">  一、正则表达式的组成<br>      一个正则表达式可以由简单的字符构成，比如 /123/, 也可以是简单和特殊字符的组合，比如：/^abc/<br>      其中，特殊字符又叫元字符，是在表达式中有特殊意义的字符，如 ^, $, . 等<br><br><br>    二、边界符（位置符）<br>      主要用来匹配字符的开始和结束位置:<br>      (1) ^: 用来匹配以...开头<br>      (2) $: 用来匹配以...结尾<br><br>    注意：<br>      (1) 不使用 ^ 和 $ 表示只要字符串中包含匹配的内容就返回 <span class="hljs-literal">true</span>, 可以多出其他任意字符<br>      (2) ^ 和 $ 在一起配合使用，表示是精确匹配, 不能多出其他字符也不能少 (必须满足数量和类型都一致)<br><br>&lt;script&gt;<br>        // 注意:在全局匹配中，不要添加精确匹配<br>        // (1) ^: 用来匹配以...开头<br>        var rg1 = /^abc/<br>        console.log(rg1.test(<span class="hljs-string">&#x27;abc&#x27;</span>)); //<span class="hljs-literal">true</span><br>        console.log(rg1.test(<span class="hljs-string">&#x27;absawq&#x27;</span>)); //<span class="hljs-literal">false</span> 没有以 abc 开头<br>        console.log(rg1.test(<span class="hljs-string">&#x27;abcabc&#x27;</span>)); //<span class="hljs-literal">true</span><br>        console.log(<span class="hljs-string">&#x27;-----------------------------------------------&#x27;</span>);<br>        // (2) $: 用来匹配以...结尾<br>        var rg1 = /abc$/<br>        console.log(rg1.test(<span class="hljs-string">&#x27;abcabc&#x27;</span>)); //<span class="hljs-literal">true</span><br>        console.log(rg1.test(<span class="hljs-string">&#x27;asqwqabc&#x27;</span>)); //<span class="hljs-literal">true</span><br>        console.log(rg1.test(<span class="hljs-string">&#x27;abca1aec&#x27;</span>)); //<span class="hljs-literal">false</span> 没有以 abc 结尾<br>        console.log(<span class="hljs-string">&#x27;-----------------------------------------------&#x27;</span>);<br>        // (2)^ $: 用来精确匹配 字符串的类型和数量必须全部符合要求<br>        var rg1 = /^abc$/<br>        console.log(rg1.test(<span class="hljs-string">&#x27;abcabc&#x27;</span>)); //<span class="hljs-literal">false</span> 必须以 abc 开头 并且以 abc 结尾 <br>        console.log(rg1.test(<span class="hljs-string">&#x27;abc&#x27;</span>)); //<span class="hljs-literal">true</span>  只有这一种符合要求 其他全是 <span class="hljs-literal">false</span><br>        console.log(rg1.test(<span class="hljs-string">&#x27;qasabc&#x27;</span>)); //<span class="hljs-literal">false</span><br>    &lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="4-字符类"><a href="#4-字符类" class="headerlink" title="4.字符类"></a>4.字符类</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs bash"> 一、字符集合 如：[xyz] <br>     表示匹配字符集合中的任意字符，中括号中只要有任意一个字符出现在字符串就满足规则<br><br>   二、中括号中的特殊字符自动转义<br>     用破折号（-）来指定一个字符范围，如：[c-f1-3A-D]<br>     <br>   注意:<br>     对于点（.）和星号（*）这样的特殊符号中括号中自动转义为原本的意义<br><br>&lt;script&gt;<br>       var rg = /[xzy]123/ //规则: 只要包含 xzy 其中任意一个再加上123 就符合条件<br>       console.log(rg.test(<span class="hljs-string">&#x27;a&#x27;</span>)); //<span class="hljs-literal">false</span><br>       console.log(rg.test(<span class="hljs-string">&#x27;x123&#x27;</span>)); //<span class="hljs-literal">true</span><br>       console.log(rg.test(<span class="hljs-string">&#x27;xz123&#x27;</span>)); //<span class="hljs-literal">true</span><br>       console.log(rg.test(<span class="hljs-string">&#x27;xzy123&#x27;</span>)); //<span class="hljs-literal">true</span><br>       console.log(rg.test(<span class="hljs-string">&#x27;yzx123&#x27;</span>)); //<span class="hljs-literal">true</span><br>       console.log(rg.test(<span class="hljs-string">&#x27;123&#x27;</span>)); //<span class="hljs-literal">false</span><br>       console.log(rg.test(<span class="hljs-string">&#x27;xzy&#x27;</span>)); //<span class="hljs-literal">false</span><br>       console.log(<span class="hljs-string">&#x27;--------------------------&#x27;</span>);<br>       var rg0 = /^[xzy]123$/ //规则:精确匹配  数量和类型都要符合条件 (数量 中括号中的任意一个加123 共4个  类型 x123 z123 y123)<br>       console.log(rg0.test(<span class="hljs-string">&#x27;a&#x27;</span>)); //<span class="hljs-literal">false</span><br>       console.log(rg0.test(<span class="hljs-string">&#x27;x123&#x27;</span>)); //<span class="hljs-literal">true</span><br>       console.log(rg0.test(<span class="hljs-string">&#x27;z123&#x27;</span>)); //<span class="hljs-literal">true</span><br>       console.log(rg0.test(<span class="hljs-string">&#x27;xz123&#x27;</span>)); //<span class="hljs-literal">false</span><br>       console.log(rg0.test(<span class="hljs-string">&#x27;123&#x27;</span>)); //<span class="hljs-literal">false</span><br>       console.log(rg0.test(<span class="hljs-string">&#x27;xzy&#x27;</span>)); //<span class="hljs-literal">false</span><br>       console.log(<span class="hljs-string">&#x27;--------------------------&#x27;</span>);<br>       //没有设定开头和结尾 那么中括号中只要有任意一个字符出现在字符串就满足规则<br>       var rg1 = /[abc]/<br>       console.log(rg1.test(<span class="hljs-string">&#x27;a&#x27;</span>)); //<span class="hljs-literal">true</span><br>       console.log(rg1.test(<span class="hljs-string">&#x27;red&#x27;</span>)); //<span class="hljs-literal">false</span><br>       console.log(rg1.test(<span class="hljs-string">&#x27;color&#x27;</span>)); //<span class="hljs-literal">true</span><br>       console.log(<span class="hljs-string">&#x27;--------------------------&#x27;</span>);<br>       // 设定了开头和结尾 那么 三选1 三个当中只能出现其中一个字符 为 <span class="hljs-literal">true</span><br>       var rg2 = /^[abc]$/ //<br>       console.log(rg2.test(<span class="hljs-string">&#x27;a&#x27;</span>)); //<span class="hljs-literal">true</span><br>       console.log(rg2.test(<span class="hljs-string">&#x27;b&#x27;</span>)); //<span class="hljs-literal">true</span><br>       console.log(rg2.test(<span class="hljs-string">&#x27;c&#x27;</span>)); //<span class="hljs-literal">true</span><br>       console.log(rg2.test(<span class="hljs-string">&#x27;abc&#x27;</span>)); //<span class="hljs-literal">false</span> 中括号里面的字符串只能出现其中一个<br>       console.log(rg2.test(<span class="hljs-string">&#x27;color&#x27;</span>)); //<span class="hljs-literal">false</span> 只能出现中括号里面的字符<br>       console.log(<span class="hljs-string">&#x27;--------------------------&#x27;</span>);<br>       // 用破折号（ - ）来指定一个字符范围， 如：/[a-zA-Z1-9]/  小写a到z 大写A到Z 数字1到9<br>       var rg3 = /[a-zA-Z1-9]/<br>       console.log(rg3.test(<span class="hljs-string">&#x27;Aqw121&#x27;</span>)); //<span class="hljs-literal">true</span><br>       console.log(rg3.test(<span class="hljs-string">&#x27;AWQW&#x27;</span>)); //<span class="hljs-literal">true</span><br>       console.log(rg3.test(<span class="hljs-string">&#x27;14233&#x27;</span>)); //<span class="hljs-literal">true</span><br>       console.log(<span class="hljs-string">&#x27;--------------------------&#x27;</span>);<br>       // 设定了开头和结尾 那么 多选1 小写a到z 大写A到Z 数字1到9 当中只能出现其中一个字符 为 <span class="hljs-literal">true</span><br>       var rg4 = /^[a-zA-Z1-9]$/<br>       console.log(rg4.test(<span class="hljs-string">&#x27;A&#x27;</span>)); //<span class="hljs-literal">true</span><br>       console.log(rg4.test(<span class="hljs-string">&#x27;r&#x27;</span>)); //<span class="hljs-literal">true</span><br>       console.log(rg4.test(<span class="hljs-string">&#x27;6&#x27;</span>)); //<span class="hljs-literal">true</span><br>       console.log(rg4.test(<span class="hljs-string">&#x27;611&#x27;</span>)); //<span class="hljs-literal">false</span> 出现了多个字符  为<span class="hljs-literal">false</span><br><br><br>        一、反向字符集合 如：[^xyz] 表示匹配没有包含在字符集合中的字符，注意：字符串中只要有一个不在中括号内的字符就满足规则<br>       var rg5 = /[^a-f]/ //规则 除了 a 到 f 之间的字符 都可以  字符串中只要有一个不在中括号内的字符就满足规则 <br>       console.log(rg5.test(<span class="hljs-string">&#x27;hello&#x27;</span>)); //<span class="hljs-literal">true</span>  只要有一个不在中括号内的字符就满足规则   h l o 都不在 a 到 f 之间 <br>       console.log(rg5.test(<span class="hljs-string">&#x27;abco&#x27;</span>)); //<span class="hljs-literal">true</span>     o 不在 a 到 f 之间 所以这一整个字符串都为 <span class="hljs-literal">true</span><br>       console.log(rg5.test(<span class="hljs-string">&#x27;abc&#x27;</span>)); //<span class="hljs-literal">false</span>    全在 a 到 f 之间<br>       console.log(<span class="hljs-string">&#x27;--------------------------&#x27;</span>);<br>       var rg6 = /^[^a-f]$/ //精确匹配 (数量:只能出现一个  类型:只能出现指定类型)<br>       console.log(rg6.test(<span class="hljs-string">&#x27;a&#x27;</span>)); //<span class="hljs-literal">false</span>  出现了 a  a 在 a 到 f 之间<br>       console.log(rg6.test(<span class="hljs-string">&#x27;z&#x27;</span>)); //<span class="hljs-literal">true</span><br>       console.log(rg6.test(<span class="hljs-string">&#x27;abc&#x27;</span>)); //<span class="hljs-literal">false</span>  精确匹配只能出现一个 并且abc都在 a 到 f 之间<br>       console.log(rg6.test(<span class="hljs-string">&#x27;sjx&#x27;</span>)); //<span class="hljs-literal">false</span>  精确匹配只能出现一个<br>   &lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="5-量词符"><a href="#5-量词符" class="headerlink" title="5.量词符"></a>5.量词符</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;<br>        // 量词符，用来制定某个字符出现次数的特殊符号 /ab*c/ <br><br>        // 1. * 表示前面的字符出现 0 次或多次, 即可有可无<br>        var rg1 = /^ab*c$/ //规则: 必须以 a 开头  b 可有可无 以 c 结尾<br>        console.log(rg1.test(<span class="hljs-string">&#x27;abbc&#x27;</span>)); //<span class="hljs-literal">true</span><br>        console.log(rg1.test(<span class="hljs-string">&#x27;ac&#x27;</span>)); //<span class="hljs-literal">true</span><br>        console.log(rg1.test(<span class="hljs-string">&#x27;aw121c&#x27;</span>)); //<span class="hljs-literal">false</span> <br>        console.log(<span class="hljs-string">&#x27;--------------------&#x27;</span>);<br><br>        // 2. + 表示前面的字符至少出现 1 次或多次, 即至少出现一次<br>        var rg2 = /^ab+c$/ //规则: 必须以 a 开头  b 至少出现一次或者一次以上 以 c 结尾<br>        console.log(rg2.test(<span class="hljs-string">&#x27;abbc&#x27;</span>)); //<span class="hljs-literal">true</span><br>        console.log(rg2.test(<span class="hljs-string">&#x27;ac&#x27;</span>)); //<span class="hljs-literal">false</span> b 至少要出现一次或者一次以上<br>        console.log(rg2.test(<span class="hljs-string">&#x27;abc&#x27;</span>)); //<span class="hljs-literal">true</span><br>        console.log(<span class="hljs-string">&#x27;--------------------&#x27;</span>);<br><br>        // 3. ? 表示前面的字符出现 0 次或 1 次, 要么不出现, 要么只出现 1 次<br>        var rg3 = /^ab?c$/ //规则: 必须以 a 开头  b 出现 0 次或 1 次, 要么不出现, 要么只出现 1 次  以 c 结尾<br>        console.log(rg3.test(<span class="hljs-string">&#x27;abbc&#x27;</span>)); //<span class="hljs-literal">false</span> 出现了 2 次<br>        console.log(rg3.test(<span class="hljs-string">&#x27;ac&#x27;</span>)); //<span class="hljs-literal">true</span> <br>        console.log(rg3.test(<span class="hljs-string">&#x27;abc&#x27;</span>)); //<span class="hljs-literal">true</span><br>        console.log(<span class="hljs-string">&#x27;--------------------&#x27;</span>);<br>        // 4. &#123;3&#125; 表示前面的字符只能出现 3 次<br>        var rg4 = /^[0-9a-z]&#123;3&#125;$/ //规则: 中括号里面的字符只能出现3次 (==3)<br>        console.log(rg4.test(<span class="hljs-string">&#x27;abbc&#x27;</span>)); //<span class="hljs-literal">false</span> 出现了 2 次<br>        console.log(rg4.test(<span class="hljs-string">&#x27;ac&#x27;</span>)); //<span class="hljs-literal">false</span> <br>        console.log(rg4.test(<span class="hljs-string">&#x27;abc&#x27;</span>)); //<span class="hljs-literal">true</span><br>        console.log(<span class="hljs-string">&#x27;--------------------&#x27;</span>);<br>        // 5. &#123;3,&#125; 表示前面的字符出现 3 次 或 3次以上<br>        var rg5 = /^[0-9a-z]&#123;3,&#125;$/ //规则: 中括号里面的字符只能出现3或三次以上 (&gt;=3)<br>        console.log(rg5.test(<span class="hljs-string">&#x27;abbc21&#x27;</span>)); //<span class="hljs-literal">true</span> 出现了3 次以上<br>        console.log(rg5.test(<span class="hljs-string">&#x27;ac&#x27;</span>)); //<span class="hljs-literal">false</span> 出现了 0 次<br>        console.log(rg5.test(<span class="hljs-string">&#x27;abc&#x27;</span>)); //<span class="hljs-literal">true</span><br>        console.log(<span class="hljs-string">&#x27;--------------------&#x27;</span>);<br>        // 6. &#123;3,5&#125; 表示前面的字符出现 3 次 到 5 次以内<br>        var rg6 = /^[0-9a-z]&#123;3,5&#125;$/ //规则: 中括号里面的字符只能出现3或三次以上 5次或者5次以下 (&gt;=3 &amp;&amp; &lt;=5)<br>        console.log(rg6.test(<span class="hljs-string">&#x27;abbc&#x27;</span>)); //<span class="hljs-literal">true</span> 出现了 4 次<br>        console.log(rg6.test(<span class="hljs-string">&#x27;ac&#x27;</span>)); //<span class="hljs-literal">false</span> 出现了 0 次<br>        console.log(rg6.test(<span class="hljs-string">&#x27;abc2121&#x27;</span>)); //<span class="hljs-literal">false</span> 超过了5次<br>        console.log(<span class="hljs-string">&#x27;--------------------&#x27;</span>);<br>    &lt;/script&gt;<br><br></code></pre></td></tr></table></figure><h3 id="6-量词重复某个模式的次数"><a href="#6-量词重复某个模式的次数" class="headerlink" title="6.量词重复某个模式的次数"></a>6.量词重复某个模式的次数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">量词符用来设定前面表达式出现的次数<br>用户名: 只能出现 数字0-9 字母a-zA-Z 下划线_ 中划线-，个数在 6 到 16 位之间 &#123;6, 16&#125;<br><br></code></pre></td></tr></table></figure><h3 id="7-用户名和表单验证"><a href="#7-用户名和表单验证" class="headerlink" title="7.用户名和表单验证"></a>7.用户名和表单验证</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;input <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;&lt;span&gt;请输入用户名&lt;/span&gt;<br>   &lt;script&gt;<br>       // 案例需求：用户名验证<br>       // 1. 如果用户名输入合法，则后面的提示信息为：用户名合法并颜色是绿色<br>       // 2. 如果用户名输入不合法，则后面的提示信息为：用户名不合法并颜色是红色<br>       var ipt = document.querySelector(<span class="hljs-string">&#x27;input&#x27;</span>)<br>       var span = document.querySelector(<span class="hljs-string">&#x27;span&#x27;</span>)<br>       var rge = /^[0-9a-zA-Z_]&#123;6,16&#125;$/<br>       ipt.addEventListener(<span class="hljs-string">&#x27;blur&#x27;</span>, <span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>           var res = rge.test(this.value) //可以把这个结果 <span class="hljs-literal">false</span> 或者 <span class="hljs-literal">true</span>用一个变量接收<br>           <span class="hljs-keyword">if</span> (res) &#123; //然后直接判断这个变量里面是 <span class="hljs-literal">false</span> 或者 <span class="hljs-literal">true</span> 即可<br>               span.innerHTML = <span class="hljs-string">&#x27;用户名合法&#x27;</span><br>               span.className = <span class="hljs-string">&#x27;right&#x27;</span><br>           &#125; <span class="hljs-keyword">else</span> &#123;<br>               span.innerHTML = <span class="hljs-string">&#x27;用户名不合法&#x27;</span><br>               span.className = <span class="hljs-string">&#x27;wrong&#x27;</span><br>           &#125;<br>       &#125;)<br>   &lt;/script&gt;<br><br></code></pre></td></tr></table></figure><h3 id="8-括号总结以及正则验证"><a href="#8-括号总结以及正则验证" class="headerlink" title="8.括号总结以及正则验证"></a>8.括号总结以及正则验证</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;<br>      // 中括号 [xyz] 字符集合：匹配方括号中的任意字符<br><br>      // 大括号 &#123;3,8&#125; 量词符：表示重复的次数<br><br>      // 小括号 (xyz): 表示一个整体 捕获组<br>      var reg3 = /^(abc)&#123;3&#125;$/ //规则: 必须出现 3 组 abc <br>      console.log(reg3.test(<span class="hljs-string">&#x27;abcabcabc&#x27;</span>)); //<span class="hljs-literal">true</span><br>      console.log(reg3.test(<span class="hljs-string">&#x27;abcabc&#x27;</span>)); //<span class="hljs-literal">false</span> 只有两组<br>      console.log(reg3.test(<span class="hljs-string">&#x27;abc1abc2abc&#x27;</span>)); //<span class="hljs-literal">false</span> 只能是 abc 不能有其他的<br><br>      // 菜鸟工具：https://c.runoob.com/front-end/854<br>  &lt;/script&gt;<br><br></code></pre></td></tr></table></figure><h3 id="9-预定义类以及座机号码验证"><a href="#9-预定义类以及座机号码验证" class="headerlink" title="9.预定义类以及座机号码验证"></a>9.预定义类以及座机号码验证</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs bash"> 一、 正则表达式中的预定义类<br>     \d：匹配 0~9 之间的任意一个数字，等价于 [0-9]<br>     \D: 匹配所有 0~9 之外的字符，等价于 [^0-9]<br>     \w: 匹配任意的字母、数字和下划线，等价于 [a-zA-Z0-9_]<br>     \W: 匹配任意的字母、数字和下划线之外的字符，等价于 [^0-9a-zA-Z_]<br>     \s: 匹配所有的空格（包括换行符，制表符，空格符等），等价于 [\t\r\n\v\f]<br>     \S：匹配所有的非空格符，等价于 [^\t\r\n\v\f]<br><br>   记忆：所有大写字符表示 “非”, 上述预定义类只表示单个字符<br><br>&lt;script&gt;<br>       //所有大写字符表示 “非”<br>       //小写 \d：匹配 0~9 之间的任意一个数字，等价于 [0-9]<br>       var rg1 = /^\d&#123;3,&#125;$/ //规则: 数字出现大于或等于3次<br>       console.log(rg1.test(<span class="hljs-string">&#x27;123345&#x27;</span>)); //<span class="hljs-literal">true</span><br>       console.log(rg1.test(<span class="hljs-string">&#x27;12awe3345&#x27;</span>)); //<span class="hljs-literal">false</span>  只能匹配数字<br>       console.log(<span class="hljs-string">&#x27;-------------------&#x27;</span>);<br>       // ----------------------------------------------------------------------------<br>       //大写 \D: 匹配所有 0~9 之外的字符，等价于 [^0-9]<br>       var rg2 = /^\D&#123;3,&#125;$/ //规则: 非数字出现大于或等于3次<br>       console.log(rg2.test(<span class="hljs-string">&#x27;123345&#x27;</span>)); //<span class="hljs-literal">true</span>  只能匹配非数字 也就是除数字之外的字符<br>       console.log(rg2.test(<span class="hljs-string">&#x27;12awe3345&#x27;</span>)); //<span class="hljs-literal">false</span>  只能匹配非数字<br>       console.log(rg2.test(<span class="hljs-string">&#x27;awrrAA&#x27;</span>)); //<span class="hljs-literal">true</span><br>       console.log(<span class="hljs-string">&#x27;-------------------&#x27;</span>);<br>       // ----------------------------------------------------------------------------      <br>       //小写 \w : 匹配任意的字母、数字和下划线，等价于 [a-zA-Z0-9_]<br>       var rg3 = /^\w&#123;3,&#125;$/ //小写 \w 规则: 字母、数字和下划线出现大于或等于3次<br>       console.log(rg3.test(<span class="hljs-string">&#x27;aqw&#x27;</span>)); //<span class="hljs-literal">true</span><br>       console.log(rg3.test(<span class="hljs-string">&#x27;12QWE33wqwqw&#x27;</span>)); //<span class="hljs-literal">true</span><br>       console.log(rg3.test(<span class="hljs-string">&#x27;1&#x27;</span>)); //<span class="hljs-literal">false</span>  小于了3次<br>       console.log(<span class="hljs-string">&#x27;-------------------&#x27;</span>);<br>       // ----------------------------------------------------------------------------     <br>       // 大写 \W: 匹配任意的字母、 数字和下划线之外的字符， 等价于[ ^ 0 - 9 a - zA - Z_]<br>       var rg4 = /^\W&#123;3,&#125;$/ //规则: 除了字母、数字和下划线之外的字符 出现大于或等于3次<br>       console.log(rg4.test(<span class="hljs-string">&#x27;aqw&#x27;</span>)); //<span class="hljs-literal">false</span><br>       console.log(rg4.test(<span class="hljs-string">&#x27;12QWE33wqwqw&#x27;</span>)); //<span class="hljs-literal">false</span><br>       console.log(rg4.test(<span class="hljs-string">&#x27;1&#x27;</span>)); //<span class="hljs-literal">false</span>  小于了3次 且是数字<br>       console.log(rg4.test(<span class="hljs-string">&#x27;%#@#&#x27;</span>)); //<span class="hljs-literal">true</span>   既不是大小写字母 也不是数字和下划线<br>       console.log(rg4.test(<span class="hljs-string">&#x27;@#&#x27;</span>)); //<span class="hljs-literal">true</span>   虽然既不是大小写字母 也不是数字和下划线 但小于了3次<br>       console.log(<span class="hljs-string">&#x27;-------------------&#x27;</span>);<br>       // ----------------------------------------------------------------------------      <br>       //小写 \s: 匹配所有的空格（包括换行符，制表符，空格符等），等价于 [\t\r\n\v\f]<br>       var rg5 = /^\s*$/ //规则: 所有 空格（包括换行符，制表符，空格符等） 出现0次或以上<br>       console.log(rg5.test(<span class="hljs-string">&#x27; &#x27;</span>)); //<span class="hljs-literal">true</span><br>       console.log(rg5.test(<span class="hljs-string">&#x27;\t\r\n\v\f&#x27;</span>)); //<span class="hljs-literal">true</span><br>       console.log(rg5.test(<span class="hljs-string">&#x27;  \t&#x27;</span>)); //<span class="hljs-literal">true</span> <br>       console.log(rg5.test(<span class="hljs-string">&#x27;%#@#&#x27;</span>)); //<span class="hljs-literal">false</span>   既不是空格 也不是换行 制表 符<br>       console.log(rg5.test(<span class="hljs-string">&#x27;@#&#x27;</span>)); //<span class="hljs-literal">false</span>   既不是空格 也不是换行 制表 符<br>       console.log(<span class="hljs-string">&#x27;-------------------&#x27;</span>);<br>       // ----------------------------------------------------------------------------      <br>       //大写 \S：匹配所有的非空格符，等价于 [^\t\r\n\v\f]<br>       var rg6 = /^\S*$/ //规则: 除了空格（包括换行符，制表符，空格符等）出现0次或以上<br>       console.log(rg6.test(<span class="hljs-string">&#x27; &#x27;</span>)); //<span class="hljs-literal">false</span>  有空格<br>       console.log(rg6.test(<span class="hljs-string">&#x27;\t\r\n\v\f&#x27;</span>)); //<span class="hljs-literal">false</span> 有换行符，制表符 等<br>       console.log(rg6.test(<span class="hljs-string">&#x27;121a ed&#x27;</span>)); //<span class="hljs-literal">false</span>  有空格<br>       console.log(rg6.test(<span class="hljs-string">&#x27;%#@#&#x27;</span>)); //<span class="hljs-literal">true</span>   既没有空格 也不是换行 制表 符<br>       console.log(rg6.test(<span class="hljs-string">&#x27;@#&#x27;</span>)); //<span class="hljs-literal">true</span>   既没有空格 也不是换行 制表 符<br>       console.log(rg6.test(<span class="hljs-string">&#x27;&#x27;</span>)); //<span class="hljs-literal">true</span>   既没有空格 也不是换行 制表 符 啥也没有 *表示出现0次或以上<br>       console.log(<span class="hljs-string">&#x27;-------------------&#x27;</span>);<br>       // ----------------------------------------------------------------------------   <br>       var rg7 = /^[0-9]\w\s?$/ //必须以数字开头 \s出现0次或一次 以数字 字母结尾<br>       console.log(rg7.test(<span class="hljs-string">&#x27;1q &#x27;</span>)); //<span class="hljs-literal">true</span><br>       console.log(<span class="hljs-string">&#x27;-------------------&#x27;</span>);<br>       // 139* 手机电话号码<br>       var rg7 = /^1[3-9]\d&#123;9&#125;/ // 规则: 以 1 开头 第二位为 3 到 9中的任意一个 最后一数字结尾 数字必须出现7次(也就是7个数字)<br>       console.log(rg7.test(<span class="hljs-string">&#x27;13135420681&#x27;</span>)); //<span class="hljs-literal">true</span><br>       console.log(<span class="hljs-string">&#x27;-------------------&#x27;</span>);<br>       // 正则中符号 | 表示 或者的关系 <br>       var rg8 = /^(abc|123)$/ //规则: 精确匹配 abc 或者 123<br>       console.log(rg8.test(<span class="hljs-string">&#x27;123&#x27;</span>)); //<span class="hljs-literal">true</span><br>       console.log(rg8.test(<span class="hljs-string">&#x27;abc&#x27;</span>)); //<span class="hljs-literal">true</span><br>       console.log(rg8.test(<span class="hljs-string">&#x27;ab1c&#x27;</span>)); //<span class="hljs-literal">false</span><br>       console.log(<span class="hljs-string">&#x27;-------------------&#x27;</span>);<br>       // 座机号码验证：010-12345678 或 0530-1234567<br>       var rg9 = /^(\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125;)$/ //规则: 以3个数字开头 以8个数字结尾 或者 以4个数字开头 以7个数字结尾<br>       console.log(rg9.test(<span class="hljs-string">&#x27;010-12345678&#x27;</span>)); //<span class="hljs-literal">true</span><br>       console.log(rg9.test(<span class="hljs-string">&#x27;0530-1234567&#x27;</span>)); //<span class="hljs-literal">true</span><br>   &lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="10-正则表达式查找和替换"><a href="#10-正则表达式查找和替换" class="headerlink" title="10.正则表达式查找和替换"></a>10.正则表达式查找和替换</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs bash">一、字符串中的替换<br>    replace(reg, 替换后的字符) 可以替换字符串中的字符，参数可以是普通字符串，也可以是正则表达式<br><br>  二、正则表达式参数 /表达式/参数<br>    指定匹配的模式：<br>    （1）/表达式/g   全局匹配<br>    （2）/表达式/i   忽略大小写进行匹配<br><br>      &lt;input <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;text&quot;</span> placeholder=<span class="hljs-string">&quot;请输入留言&quot;</span>&gt;<br>  &lt;script&gt;<br>      var str = <span class="hljs-string">&#x27;abC123abC678abc345c&#x27;</span><br>          // 把所有的 c 替换成 a<br>          // 方法1 只能替换第一个遇见的 c 要想全部替换 需要利用循环<br>      str = str.replace(<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br>      console.log(str);<br>      console.log(<span class="hljs-string">&#x27;-------------------&#x27;</span>);<br>      // --------------------------------------------------------------------------------<br>      // 方法2 利用 正则表达式<br>      str = str.replace(/c/gi, <span class="hljs-string">&#x27;a&#x27;</span>) //g 全局匹配 匹配所有符号正则表达式的内容，  i 忽略大小写进行匹配<br>      console.log(str);<br>      // match 方法可以配合正则表达式, 从字符串中找出所有匹配正则的字符<br>      var reg = /\d&#123;3&#125;/gi //定义一个正则表达式<br>      var res = str.match(reg) //str 调用 match 方法把 str 字符串里面所有符合正则表达式的元素找出来放入一个数组 定义一个变量 res 接收<br>      console.log(res); //打印这个数组<br>      // 替换敏感词 (傻叉)<br>      var ipt = document.querySelector(<span class="hljs-string">&#x27;input&#x27;</span>);<br>      ipt.addEventListener(<span class="hljs-string">&#x27;keyup&#x27;</span>, <span class="hljs-function"><span class="hljs-title">function</span></span>() &#123; //键盘抬起事件<br>          this.value = this.value.replace(/傻叉|傻\d*叉|sc/gi, <span class="hljs-string">&#x27;**&#x27;</span>) //把所有的 傻叉 傻叉中间的所有次数的空格 字母 sc 全局 不分大小写的替换为**<br>      &#125;)<br>  &lt;/script&gt;<br><br></code></pre></td></tr></table></figure><h2 id="js高级第五天"><a href="#js高级第五天" class="headerlink" title="js高级第五天"></a>js高级第五天</h2><h3 id="1-es6介绍"><a href="#1-es6介绍" class="headerlink" title="1.es6介绍"></a>1.es6介绍</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。<br><br>ECMAScript 和 JavaScript 的关系<br>一个常见的问题是，ECMAScript 和 JavaScript 到底是什么关系？<br><br>要讲清楚这个问题，需要回顾历史。1996 年 11 月，JavaScript 的创造者 Netscape 公司，决定将 JavaScript 提交给标准化组织 ECMA，希望这种语言能够成为国际标准。次年，ECMA 发布 262 号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript，这个版本就是 1.0 版。<br><br>该标准从一开始就是针对 JavaScript 语言制定的，但是之所以不叫 JavaScript，有两个原因。一是商标，Java 是 Sun 公司的商标，根据授权协议，只有 Netscape 公司可以合法地使用 JavaScript 这个名字，且 JavaScript 本身也已经被 Netscape 公司注册为商标。二是想体现这门语言的制定者是 ECMA，不是 Netscape，这样有利于保证这门语言的开放性和中立性。<br><br>因此，ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现（另外的 ECMAScript 方言还有 JScript 和 ActionScript）。日常场合，这两个词是可以互换的。<br></code></pre></td></tr></table></figure><h3 id="2-let-const关键字声明常量"><a href="#2-let-const关键字声明常量" class="headerlink" title="2.let,const关键字声明常量"></a>2.let,const关键字声明常量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs bash"> 一、<span class="hljs-built_in">let</span> 作用<br>      用来声明一个有块级作用域的变量，使用方法和 var 一样<br><br>    二、<span class="hljs-built_in">let</span> 定义变量的特点<br>      1. 只在声明时的块或子块中可用<br>      2. 不存在变量提升，只能先声明再使用<br>      3. 存在“暂存死区”<br>      4. 同一作用域下不能重复声明同一变量<br>      5. 声明的变量不会挂载在 window 对象上 <br>    <br>    三、暂时性死区的本质<br>      只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，<br>      只有等到声明变量的那一行代码出现，才可以获取和使用该变量。<br><br> &lt;script&gt;<br>        // es6 中的作用域: 3种<br>        // -------------------------------1. 只在声明时的块或子块中可用-----------------------------------------------------------------<br>        &#123;<br>            <span class="hljs-built_in">let</span> num1 = 10<br>            console.log(num1); //可以<br>            &#123;<br>                console.log(num1); //也可以 因为有作用域链向上一级查找<br><br>            &#125;<br>        &#125;<br>        // console.log(num1); //报错<br>        console.log(<span class="hljs-string">&#x27;--------------------&#x27;</span>);<br>        // ------------------------------- 1.1 <span class="hljs-keyword">if</span> 判断语句 中使用 <span class="hljs-built_in">let</span>-----------------------------------------------------------------<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-built_in">let</span> num2 = 20<br>            console.log(num2); //可以<br><br>        &#125;<br>        // console.log(num2); //报错<br>        console.log(<span class="hljs-string">&#x27;--------------------&#x27;</span>);<br>        // -------------------------------1.2 <span class="hljs-keyword">for</span> 循环中使用 <span class="hljs-built_in">let</span>-----------------------------------------------------------------<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">let</span> i = 0; i &lt; 5; i++) &#123;<br>            console.log(i); //可以<br>        &#125;<br>        // console.log(i); //报错<br>        console.log(<span class="hljs-string">&#x27;--------------------&#x27;</span>);<br>        // ------------------------------------------------------------------------------------------------<br>        // 2. 不存在变量提升，只能先声明再使用<br>        // console.log(num3); //报错<br>        <span class="hljs-built_in">let</span> num3 = 30;<br>        // ------------------------------------------------------------------------------------------------<br>        // 3. 存在“暂存死区” ==&gt; 存在但是无法访问到 (目的: 要求变量必须先声明再使用)<br>        <span class="hljs-built_in">let</span> num4 = 40<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>            console.log(num4);<br>            // 在查找的时候 会使用就近原则 先找自己局部 找到了下面的 <span class="hljs-built_in">let</span> num4 = 40  然后就报错了<br>            // 因为变量必须先声明再使用 所以即使外面有全局变量 但是因为这里已经找到但是无法提前访问到 所以报错了 那么也就无法再去外面找<br>            <span class="hljs-built_in">let</span> num4 = 40<br>        &#125;<br>        // ------------------------------------------------------------------------------------------------<br>        // 4. 声明的变量不会挂载在 window 对象上 <br>        <span class="hljs-built_in">let</span> num5 = 50<br>        console.log(window.num4); //undefined window 上找不到这个属性<br><br>        // 5. 同一作用域下不能重复声明同一变量<br>        // <span class="hljs-built_in">let</span> a = 1;<br>        // <span class="hljs-built_in">let</span> a = 2;<br>        // console.log(a); //报错<br>    &lt;/script&gt;<br><br>------- const 作用--------------------------------------------------------------------------------------------------------<br>       <br>      用来声明一个有块级作用域的常量(内存地址不能变化的量)<br><br>    二、const 定义常量的特点<br>      1. 声明常量时必须要初始化值<br>      2. 同样具有块级作用域和“暂存死区”<br>      3. 赋值为简单数据类型时，不能直接修改值<br>      4. 赋值为复杂数据类型时，可以修改对象内部的属性和方法<br> &lt;script&gt;<br>        //  1. 声明常量时必须要初始化值 (赋值)<br>        const age1 = 10; //正确<br>        // const age2 //错误<br>        // ----------------------------------------------------------------------------------<br><br>        //  2. const 常量赋值为简单数据类型时，不能直接修改值<br>        const age3 = 20;<br>        // age3 = 30; //不可以直接修改值<br>        // ----------------------------------------------------------------------------------<br>        //  3. const 常量赋值为复杂数据类型时，可以修改对象内部的属性和方法<br>        const date = &#123;<br>            a: 1,<br>            b: 2<br>        &#125;<br>        date.a = 10; // 可以直接修改 原因是 data 的内存地址值没有发生改变<br>        // date = [] //会报错  原因是 data 的内存地址值发生了改变<br>        // ----------------------------------------------------------------------------------<br><br>        //  4. 同样具有块级作用域和 “暂存死区”<br>        // const age4 = 40;<br><br>        // &#123;<br>        //     console.log(age4);<br>        //     const age4 = 40<br>        // &#125;<br>        // ----------------------------------------------------------------------------------<br><br>        // 注意: const 常量不能重新赋值一个新对象, 因为地址值发生了改变<br>        // <span class="hljs-keyword">for</span> (const i = 0; i &lt; 3; i++) &#123; //<span class="hljs-keyword">for</span> 循环中不能使用 const<br><br>        // &#125;<br>        // ------------------------------------------------------------------------------------------ <br>        // <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>        //     const num = 10<br>        // &#125;<br>        // console.log(num); //报错 因为块级作用域的特点<br>    &lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="3-经典面试题"><a href="#3-经典面试题" class="headerlink" title="3.经典面试题"></a>3.经典面试题</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;<br>  // <span class="hljs-keyword">for</span> 循环中使用 <span class="hljs-built_in">let</span> 定义计数变量<br>  <br>  <span class="hljs-keyword">for</span> (<span class="hljs-built_in">let</span> i = 0; i &lt; 5; i++) &#123;<br>    setTimeout(<span class="hljs-function"><span class="hljs-title">function</span></span> () &#123;<br>      console.log(i)<br>    &#125;, 100)<br>  &#125;<br>  <br>  // 面试题<br>  <span class="hljs-built_in">let</span> arr = []<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-built_in">let</span> i = 0; i &lt; 2; i++) &#123;<br>    arr[i] = <span class="hljs-function"><span class="hljs-title">function</span></span> () &#123;<br>      console.log(i)<br>    &#125;<br>  &#125;<br><br>  arr[0]()<br>  arr[1]()<br>&lt;/script&gt;<br><br></code></pre></td></tr></table></figure><h3 id="4-let-const-var关键字的区别"><a href="#4-let-const-var关键字的区别" class="headerlink" title="4.let,const,var关键字的区别"></a>4.let,const,var关键字的区别</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"> 变量的使用建议：<br>（1） 优先使用 const 关键字声明固定不变的量  常量<br>（2） 使用 <span class="hljs-built_in">let</span> 关键字声明变化的量    变量<br>（3） 兼容性考虑 或 基于 jQuery 的项目使用 var; 基于 vue 的项目 <span class="hljs-built_in">let</span>/const<br><br></code></pre></td></tr></table></figure><h3 id="5-数组解构赋值"><a href="#5-数组解构赋值" class="headerlink" title="5.数组解构赋值"></a>5.数组解构赋值</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs bash">一、解构赋值（强大）<br>    可以从数组或对象中，把值取出来，再赋值给对应的变量<br><br>  二、对数组进行解构<br>    <span class="hljs-built_in">let</span> [a, b, ...] = 数组<br>    使用变量名和对应位置的数组元素一一匹配，匹配成功就把元素赋值给变量<br><br>  三、使用注意<br>    (1) 没有解构成功的变量，值为 undefined<br>    (2) 变量的位置和数组中值的位置一一对应<br><br>    <br>  &lt;script&gt;<br>      // 1. 对数组进行解构<br>      <span class="hljs-built_in">let</span> arr = [1, 2, 3, 4]<br>      <span class="hljs-built_in">let</span> [a, b, c, d] = arr<br>      console.log(a, b, c, d);<br>      console.log(<span class="hljs-string">&#x27;-----------------&#x27;</span>);<br><br>      // 2. 没有解构成功的变量，值为 undefined<br>      <span class="hljs-built_in">let</span> arr1 = [1, 2]<br>      <span class="hljs-built_in">let</span> [a1, b1, c1] = arr1<br>      console.log(a1, b1, c1); //没有第三个值 所以 c1 undefined<br>      console.log(<span class="hljs-string">&#x27;-----------------&#x27;</span>);<br><br>      // 3. 不需要解构的元素可以使用 逗号 隔开<br>      <span class="hljs-built_in">let</span> arr2 = [1, 2, 3, 4]<br>      <span class="hljs-built_in">let</span> [, , a2] = arr2<br>      console.log(a2); //  3<br>      console.log(<span class="hljs-string">&#x27;-----------------&#x27;</span>);<br><br>      // 4. 交换两个变量<br>      <span class="hljs-built_in">let</span> num1 = 10<br>      <span class="hljs-built_in">let</span> num2 = 20;<br>      [aa, bb] = [num2, num1]<br>      console.log(aa, bb);<br><br>      // 注意: 无分号写法中, 以 () 或 [] 开头的语句前要加分隔符(! ;)<br>  &lt;/script&gt;<br><br></code></pre></td></tr></table></figure><h3 id="6-对象解构赋值别名"><a href="#6-对象解构赋值别名" class="headerlink" title="6.对象解构赋值别名"></a>6.对象解构赋值别名</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;<br>       // 如何给解构后的变量起个别名 : 原名:别名<br>       <span class="hljs-built_in">let</span> obj = &#123;<br>           name: <span class="hljs-string">&#x27;张三&#x27;</span>,<br>           age: 18,<br>           height: <span class="hljs-string">&#x27;175cm&#x27;</span>,<br>           weight: <span class="hljs-string">&#x27;65kg&#x27;</span><br>       &#125;<br>       <span class="hljs-built_in">let</span> &#123;<br>           name: name2, //原名:别名<br>           height<br>       &#125; = obj<br>       console.log(name2);<br>       // ---------------------------------------------------<br>       <span class="hljs-built_in">let</span> data = &#123;<br>               id: 1,<br>               name: <span class="hljs-string">&#x27;家电&#x27;</span>,<br>               goods: &#123;<br>                   id: 2,<br>                   name: <span class="hljs-string">&#x27;洗衣机&#x27;</span><br>               &#125;<br>           &#125;<br>           // 解构 goods 下的 name 值 和 id 值<br>       <span class="hljs-built_in">let</span> &#123;<br>           goods: &#123;<br>               name,<br>               id<br>           &#125;<br>       &#125; = data<br>       console.log(name, id);<br>   &lt;/script&gt;<br><br></code></pre></td></tr></table></figure><h3 id="7-箭头函数"><a href="#7-箭头函数" class="headerlink" title="7.箭头函数"></a>7.箭头函数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs bash">一、箭头函数表达式 （简洁）<br>    () =&gt; &#123;&#125; <br><br>  二、箭头函数的特点<br>    1. 一般不会单独使用, 可以当做匿名函数进行赋值 \ 传参 \ 返回值<br>    2. 如果函数体只有一行代码，并代码执行结果就是返回值, 可以同时省略大括号和 <span class="hljs-built_in">return</span><br>    3. 如果形参只有一个, 可以省略小括号<br>    4. 内部没有 arguments 这个内置对象<br><br>&lt;script&gt;<br>      // 1. 定义一个箭头函数<br>      const str = () =&gt; &#123;<br>          console.log(<span class="hljs-string">&#x27;hello&#x27;</span>);<br>      &#125;<br>      str();<br><br>      // 计算两个数的和<br>      const fn = (num1, num2) =&gt; num1 + num2;<br>      console.log(fn(20, 30));<br><br>      // 2. 函数体只有一行代码, 结果就是返回值时, 可以直接省略大括号 <br>      const fn1 = (a, b) =&gt; a + b; //省略大括号<br>      console.log(fn1(30, 30));<br><br>      // 使用箭头函数遍历数组<br>      var arr1 = [1, 2, 3, 4, 5]<br>      arr1.forEach(itme =&gt; console.log(itme))<br><br>      // 3. 如果形参只有一个, 可以省略小括号 <br>      const fn2 = num3 =&gt; console.log(num3); //省略小括号<br>      fn2(<span class="hljs-string">&#x27;你好&#x27;</span>)<br><br>      // 筛选出数组中所有的偶数<br>      var arr2 = [1, 2, 3, 4, 5, 6, 7]<br>      var newArr = arr2.filter(itme =&gt; itme % 2 == 0)<br>      console.log(newArr);<br>      // 注意:如果 大括号里需要多行代码 也就是一行不够的时候，千万不能省略大括号<br>  &lt;/script&gt;<br><br><br>  -----箭头函数2.------------------------------------<br><br>   &lt;script&gt;<br>      // (★★★) 箭头函数没有自己的 this, 它里面的 this 指向箭头函数所处位置的 this<br><br>      // 例子1:<br>      // const obj = &#123;<br>      //     name: <span class="hljs-string">&#x27;张三&#x27;</span><br>      // &#125;<br><br>      // <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">fn</span></span>() &#123;<br>      //     console.log(this)<br>      //     <span class="hljs-built_in">return</span> () =&gt; &#123;<br>      //         console.log(this)<br>      //     &#125;<br>      // &#125;<br><br>      // const resFn = fn.call(obj)<br>      // resFn()<br><br><br>      // // 例子2:<br>      // const obj = &#123;<br>      //     age: 20,<br>      //     say: () =&gt; &#123;<br>      //         alert(this.age)<br>      //     &#125;<br>      // &#125;<br>      // obj.say()<br>      // console.log(obj.foo)<br>      // 例子3<br>      var btn = document.querySelector(<span class="hljs-string">&#x27;button&#x27;</span>)<br>      btn.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>              setTimeout(() =&gt; &#123;<br>                  this.disabled = <span class="hljs-literal">true</span> //这里的this原本指向 window 但可以用箭头函数将其指向所处位置的 this<br>              &#125;, 3000)<br>          &#125;)<br>          // this 情况讨论<br>          // (1) 非函数中的 this 指向 window<br>          // (2) es5 中函数的 this 指向函数的调用者<br>          // (3) call, apply, <span class="hljs-built_in">bind</span> 这三种手动改变 this 的情况特殊对待, this 指向传递的第一个参数<br>          // (4) es6 中的箭头函数没有自己的 this, 指向所处位置的 this<br>  &lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="8-剩余参数"><a href="#8-剩余参数" class="headerlink" title="8.剩余参数"></a>8.剩余参数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;<br>        // 1. 剩余参数语法(...变量名): 允许我们将剩下的所有参数表示为一个数组<br>        <span class="hljs-keyword">function</span> fn(a, ...b) &#123;<br>            console.log(a); //1<br>            console.log(b); // 数组 [2,3,4,5,6]<br>        &#125;<br>        fn(1, 2, 3, 4, 5, 6)<br><br>        // 2. 用来计算多个数的和 (1, 2, 3, 4, 5)<br>        const reg = (...num) =&gt; &#123;<br>            console.log(num); // [1, 2, 3, 4, 5]<br>            <span class="hljs-built_in">let</span> sum = 0 //定义一个变量<br>            num.forEach(item =&gt; sum += item) //变量数组定义箭头函数求和<br>            console.log(sum); //打印和<br>        &#125;<br>        reg(1, 2, 3, 4, 5)<br>    &lt;/script&gt;<br><br></code></pre></td></tr></table></figure><h3 id="9-剩余参数配合解构赋值"><a href="#9-剩余参数配合解构赋值" class="headerlink" title="9.剩余参数配合解构赋值"></a>9.剩余参数配合解构赋值</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;<br>       // 剩余参数使用在解构赋值中, 表示数组中剩余的所有元素 ，或者对象中剩余的所有属性<br>       const arr = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;orange&#x27;</span>, <span class="hljs-string">&#x27;yellow&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;black&#x27;</span>]<br><br>       // 1. 把数组中剩下的元素组成新的数组<br>       <span class="hljs-built_in">let</span> [a, b, ...c] = arr<br>       console.log(a); //red<br>       console.log(b); //orange<br>       console.log(c); //[<span class="hljs-string">&quot;yellow&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>, <span class="hljs-string">&quot;black&quot;</span>]<br>       // ----------------------------------------------------------------------------------<br><br>       const obj = &#123;<br>           name: <span class="hljs-string">&#x27;小明&#x27;</span>,<br>           age: 12,<br>           height: <span class="hljs-string">&#x27;170cm&#x27;</span>,<br>           weight: <span class="hljs-string">&#x27;135kg&#x27;</span>,<br>       &#125;;<br>       // 2. 把对象剩下的属性组成一个新对象<br>       <span class="hljs-built_in">let</span> &#123;<br>           name,<br>           ...aa<br>       &#125; = obj<br>       console.log(name); //小明<br>       console.log(aa); //&#123;age: 12, height: <span class="hljs-string">&quot;170cm&quot;</span>, weight: <span class="hljs-string">&quot;135kg&quot;</span>&#125;<br><br>       // 3. 使用剩余参数快速实现浅拷贝<br>       <span class="hljs-built_in">let</span> &#123;...obj1<br>       &#125; = obj<br>       console.log(obj1); //&#123;name: <span class="hljs-string">&quot;小明&quot;</span>, age: 12, height: <span class="hljs-string">&quot;170cm&quot;</span>, weight: <span class="hljs-string">&quot;135kg&quot;</span>&#125;<br>   &lt;/script&gt;<br><br></code></pre></td></tr></table></figure><h3 id="10-拓展运算符"><a href="#10-拓展运算符" class="headerlink" title="10.拓展运算符"></a>10.拓展运算符</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;<br>      // 1. 拓展运算符（展开语法 或 spred运算符） ...对象名 或 ...数组名<br>      // 作用：把数组或对象转为用逗号分隔的参数形式<br>      const arr1 = [3, 4, 50, 6, 7]<br>      <span class="hljs-built_in">let</span> arr2 = [...arr1]<br>      console.log(arr2); //[3, 4, 50, 6, 7]<br><br>      // <span class="hljs-keyword">function</span> fn(foo) &#123;<br>      //     console.log(foo);<br>      // &#125;<br>      // fn(...arr1) //就一个3 因为形参就一个 只能接受一个<br><br>      // 2. 使用拓展运算符也可以快速完成浅拷贝<br>      console.log([...arr1]); //[3, 4, 50, 6, 7]<br>  &lt;/script&gt;<br><br></code></pre></td></tr></table></figure><h3 id="11-拓展运算符应用"><a href="#11-拓展运算符应用" class="headerlink" title="11.拓展运算符应用"></a>11.拓展运算符应用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs bash"> &lt;script&gt;<br>        // 拓展运算符的应用<br>        // 1. 用来合并数组<br>        const arr1 = [1, 2, 3]<br>        const arr2 = [4, 5, 6]<br><br>        // 1, concat() 方法 合并数组<br>        const res = arr1.concat(arr2);<br>        console.log(res);<br><br>        // 2, push() 方法<br>        // arr1.push(...arr2);<br>        // console.log(arr1);<br>        // 3,新增方法 拓展运算符<br>        const res1 = [...arr1, ...arr2]<br>        console.log(res1);<br><br>        // 2. 求数组中的最大值<br>        const arr3 = [5, 4, 3, 2, 1]<br>        const res2 = Math.max(...arr3)<br>        console.log(res2);<br><br>        // 对象的拓展<br>        const obj = &#123;<br>            name: <span class="hljs-string">&#x27;沈剑心&#x27;</span>,<br>            age: 18,<br>            color: <span class="hljs-string">&#x27;black&#x27;</span><br>        &#125;<br>        const obj1 = &#123;<br>            height: 175,<br>            color: <span class="hljs-string">&#x27;fff&#x27;</span><br>        &#125;<br>        console.log(&#123;...obj<br>        &#125;); //注意要加大括号<br>        console.log(&#123;...obj,<br>            ...obj1<br>        &#125;); //注意要加大括号 如果两个对象有相同属性 后面的会覆盖前面的<br>    &lt;/script&gt;<br><br>  &lt;span&gt;1&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;<br>    &lt;script&gt;<br>        // 1. 使用拓展运算符拓展字符串和伪数组<br>        // 字符串的拓展<br>        <span class="hljs-built_in">let</span> str = <span class="hljs-string">&#x27;hello&#x27;</span><br>        console.log(...str); // h e l l o<br><br>-------拓展运算符的应用2--------------------------------<br><br>        // 伪数组的拓展<br>        var spans = document.querySelectorAll(<span class="hljs-string">&#x27;span&#x27;</span>)<br><br>        // 将伪数组转化为真数组 (伪数组不能使用数组的原生方法 如 push ,concat,Math等等)<br>        // 转化为真数组后 就可以使用原生方法了<br>        const arr = [...spans]<br>        arr.push(123) //可以 push<br>        console.log(arr);<br>    &lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="12-模板字符串"><a href="#12-模板字符串" class="headerlink" title="12.模板字符串"></a>12.模板字符串</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;table&gt;<br><br>   &lt;/table&gt;<br><br>   &lt;script&gt;<br>       // 模板字符串 (强大的字符串变量拼接语法)<br><br>       // 1. 使用反引号（``）代替单双引号，<br>       <span class="hljs-built_in">let</span> str = `hello`<br>       console.log(str);<br>       // 使用 <span class="hljs-variable">$&#123;变量名或表达式&#125;</span> 代替原来的 <span class="hljs-string">&#x27;引引加加&#x27;</span><br>       <span class="hljs-built_in">let</span> name = `沈剑心`<br>       <span class="hljs-built_in">let</span> age = 10<br>       console.log(`<span class="hljs-variable">$&#123;name&#125;</span>今年<span class="hljs-variable">$&#123;age&#125;</span>岁了`);<br><br><br>       // 2. 模板字符串支持换行<br>       const obj = &#123;<br>           name: <span class="hljs-string">&#x27;沈剑心&#x27;</span>,<br>           subjext: <span class="hljs-string">&#x27;语文&#x27;</span>,<br>           score: 80<br>       &#125;<br>       <span class="hljs-built_in">let</span> str2 = `<br>       &lt;tr&gt;<br>         &lt;td&gt;<span class="hljs-variable">$&#123;obj.name&#125;</span>&lt;/td&gt;<br>         &lt;td&gt;<span class="hljs-variable">$&#123;obj.subjext&#125;</span>&lt;/td&gt;<br>         &lt;td&gt;<span class="hljs-variable">$&#123;obj.score&#125;</span>&lt;/td&gt;<br>        &lt;/tr&gt;` //可以换行写<br><br>       const table = document.querySelector(<span class="hljs-string">&#x27;table&#x27;</span>)<br>       table.innerHTML = str2<br><br>       // 3. 在模板字符串中可以放任意的表达式 (如三元表达式, 函数调用, 逻辑运算符, +-*/...)<br>       const foo = () =&gt; <span class="hljs-string">&#x27;abc&#x27;</span><br>       <span class="hljs-built_in">let</span> str3 = `hello<span class="hljs-variable">$&#123;true?&#x27;abc&#x27;:def&#125;</span> --- <span class="hljs-variable">$&#123;foo()&#125;</span>`<br>       console.log(str3);<br>   &lt;/script&gt;<br><br></code></pre></td></tr></table></figure><h3 id="13-Array-from应用"><a href="#13-Array-from应用" class="headerlink" title="13.Array.from应用"></a>13.Array.from应用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;<br>       // 1. Array.from(param[, fn]) 把其他类型的数据转化为数组<br>       // 注意 对象没有办法转成数组 因为对象本身是无序的 第一项第二项都是谁不好分辨<br>       // 除非这个对象的属性名是按照索引来命名的，比如下面这个obj 对象 这样才可以<br>       const obj = &#123;<br>           0: <span class="hljs-string">&#x27;a&#x27;</span>,<br>           1: <span class="hljs-string">&#x27;b&#x27;</span>,<br>           length: 2<br>       &#125;<br>       const arr = Array.from(obj)<br><br>       console.log(arr); //[<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>]<br>       // 拿到所有的参数并且转为数组<br>       // console.log([...obj]); 对象没有办法通过拓展运算符快速转成数组<br><br><br><br><br>       //  (了解)第二个可选参数 fn 用于对转化后的数组进行遍历修改<br>       const arr2 = Array.from(obj, <span class="hljs-keyword">function</span>(item) &#123;<br>           console.log(item); // a, b<br>           <span class="hljs-built_in">return</span> item + <span class="hljs-string">&#x27;1&#x27;</span> //字符串拼接<br>       &#125;)<br>       console.log(arr2); //[<span class="hljs-string">&quot;a1&quot;</span>, <span class="hljs-string">&quot;b1&quot;</span>]<br>   &lt;/script&gt;<br><br></code></pre></td></tr></table></figure><h3 id="14-数组find方法"><a href="#14-数组find方法" class="headerlink" title="14.数组find方法"></a>14.数组find方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;<br>       // find 方法用于查找数组中符合条件的第一个元素，<br>       // 返回值: 找到就返回这个元素, 没有找到则返回 undefined<br>       const arr = [5, 12, 8, 13, 44]<br><br>       // 找出大于 10 的第一个元素<br>       const res = arr.find(item =&gt; item &gt; 10)<br>       console.log(res); //12<br><br><br><br>       // find 方法 与其他方法的区别<br>       // fiLter()//找出所有符合条件的元素<br>       // some()//返回值为布尔值 找到为 <span class="hljs-literal">true</span> 找不到为 <span class="hljs-literal">false</span><br>       // indexOf()//返回的是索引号 且不能接受函数<br>   &lt;/script&gt;<br><br></code></pre></td></tr></table></figure><h3 id="15-数组findIndex方法"><a href="#15-数组findIndex方法" class="headerlink" title="15.数组findIndex方法"></a>15.数组findIndex方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;<br>      // findIndex() 方法用于查找数组中符合条件的第一个元素的索引，<br>      // 返回值: 找到就返回当前元素的所以, 没有找到始终返回 -1 <br>      // 与 indexOf() 一样 但是 indexOf() 不能接受函数<br>      const arr = [5, 12, 8, 130, 44]<br><br><br>      // 找元素中大于 10 的元素索引<br>      const str = arr.findIndex(item =&gt; item &gt; 10)<br>      console.log(str); //索引号为 1 的位置的数字是第一个符合条件的<br>  &lt;/script&gt;<br><br></code></pre></td></tr></table></figure><h3 id="16-includes、map方法"><a href="#16-includes、map方法" class="headerlink" title="16.includes、map方法"></a>16.includes、map方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;<br>      // 1. includes() 方法判断数组是否包含给定的值<br>      // 返回值: 如果包含则返回 <span class="hljs-literal">true</span>，否则返回 <span class="hljs-literal">false</span><br>      const arr = [5, 12, 8, 130, 44]<br><br>      // 判断数组中是否包含 44 <br>      console.log(arr.includes(44)); //<span class="hljs-literal">true</span><br><br>      // 这个元素与 indexOf() 一样 都可以使用<br>      <span class="hljs-built_in">let</span> str = arr.indexOf(44) !== -1;<br>      console.log(str); //<span class="hljs-literal">true</span><br><br><br>      // 注意: 和其他查找方法的区别 ==&gt;  includes 只能接受一个固定值，不能接受一个函数<br><br>      // 2. map() 方法基于原数组去创建一个新数组<br>      // 返回值: 新数组<br>      const arr2 = [2, 4, 6, 8, 10]<br>      const sre = arr2.map(item =&gt; item / 2) //数组中的每一个元素都除以 2 结果返回给一个基于原数组去创建的一个新数组<br>      console.log(arr2); //原数组 [2, 4, 6, 8, 10]  <br>      console.log(sre); //新数组 [1, 2, 3, 4, 5]<br>  &lt;/script&gt;<br><br></code></pre></td></tr></table></figure><h3 id="17-startWidth和endWidth方法"><a href="#17-startWidth和endWidth方法" class="headerlink" title="17.startWidth和endWidth方法"></a>17.startWidth和endWidth方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;<br>      // 1. startsWith() 方法：判断字符串是否以某些字符开头，返回 Boolean 是则返回 <span class="hljs-literal">true</span> 不是则返回 <span class="hljs-literal">false</span><br>      const str = <span class="hljs-string">&#x27;hello wrold&#x27;</span><br>      console.log(str.startsWith(<span class="hljs-string">&#x27;hello&#x27;</span>)); //<span class="hljs-literal">true</span><br>      // 正则表达式 也可以<br>      const reg = /^hello/<br>      console.log(reg.test(str)); //<span class="hljs-literal">true</span><br><br><br>      // 2. endsWith() 方法：判断字符串是否以某些字符结尾，返回 Boolean 是则返回 <span class="hljs-literal">true</span> 不是则返回 <span class="hljs-literal">false</span><br>      console.log(str.endsWith(<span class="hljs-string">&#x27;wrold&#x27;</span>)); //<span class="hljs-literal">true</span><br>      // 正则表达式 也可以<br>      const reg1 = /wrold$/<br>      console.log(reg1.test(str)); //<span class="hljs-literal">true</span><br>  &lt;/script&gt;<br><br></code></pre></td></tr></table></figure><h3 id="18-repeat方法"><a href="#18-repeat方法" class="headerlink" title="18.repeat方法"></a>18.repeat方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;<br>      // repeat(n) 方法：用于将某个字符串重复 n 次, 返回重复后的新字符串<br>      <span class="hljs-built_in">let</span> str = <span class="hljs-string">&#x27;123&#x27;</span><br>      str = str.repeat(10) //重复10次<br>      console.log(str);<br>  &lt;/script&gt;<br><br></code></pre></td></tr></table></figure><h3 id="19-Set数据结构"><a href="#19-Set数据结构" class="headerlink" title="19.Set数据结构"></a>19.Set数据结构</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;<br>       //  es6 中提供了新的数据结构 Set, 它类似于数组，但所有的元素都是唯一的，没有重复值<br><br>       // 1. 创建一个 <span class="hljs-built_in">set</span> 类型的数据 ===&gt; new Set(数组)<br>       const mySet = new Set([1, 2, 3, 5, 6, 1, 3, 4, 5, 6]) //注意 接收的参数必须是一个数组<br>       console.log(mySet); // <span class="hljs-built_in">set</span> 数据中的元素都是唯一的，出现的重复元素会自动去重<br>       console.log(mySet.size); //mySet.size 打印当前 <span class="hljs-built_in">set</span> 的长度<br>   &lt;/script&gt;<br><br></code></pre></td></tr></table></figure><h3 id="20-利用set数据去重"><a href="#20-利用set数据去重" class="headerlink" title="20.利用set数据去重"></a>20.利用set数据去重</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;<br>       // 1. 向 <span class="hljs-built_in">set</span> 结构中添加数据<br>       //注意！<span class="hljs-built_in">set</span>本身是一个对象 所以<span class="hljs-built_in">set</span>方法的返回值是对象类型<br>       const <span class="hljs-built_in">set</span> = new Set()<br>       set.add(1)<br>       set.add(2)<br>       set.add(3)<br>       console.log(<span class="hljs-built_in">set</span>); //&#123;1,2,3&#125; <br>       console.log(<span class="hljs-string">&#x27;-----------------------------&#x27;</span>);<br><br><br>       // 2. 把 <span class="hljs-built_in">set</span> 类型的数据转成数组<br>       const mySet = new Set([1, 2, 3, 4]);<br>       console.log(mySet); //&#123;1,2,3,4&#125;   此时是对象<br>       console.log(<span class="hljs-string">&#x27;-----------------------------&#x27;</span>);<br>       // 方法1 <br>       // const arr = Array.from(mySet);<br>       // 方法2 更简单<br>       const arr = [...mySet]; //直接 大括号 [...目标元素即可]<br>       console.log(arr);<br>       console.log(<span class="hljs-string">&#x27;-----------------------------&#x27;</span>);<br><br><br>       // 3. 利用 <span class="hljs-built_in">set</span> 数据类型的不重复性进行数组去重<br>       const arr2 = [1, 2, 3, 4, 3, 5, 6, 7, 2, 4]<br>       const set2 = [...new Set(arr2)]<br>       console.log(set2);<br>       // 总结: 数组去重的方法<br>       // 原生 双重 <span class="hljs-keyword">for</span> 循环<br>       // indexOf 方法<br>       // filter 方法<br>       // <span class="hljs-built_in">set</span> 方法<br>   &lt;/script&gt;<br><br></code></pre></td></tr></table></figure><h3 id="21-set操作"><a href="#21-set操作" class="headerlink" title="21.set操作"></a>21.set操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;<br>       const mySet = new Set([2, 4, 5, 7])<br><br>       // 1. 向 <span class="hljs-built_in">set</span> 中添加元素 add()<br>       mySet.add(8)<br>       console.log(mySet);<br><br><br>       // 2. 从 <span class="hljs-built_in">set</span> 中删除元素 delete()<br>       mySet.delete(4);<br>       console.log(mySet);<br><br><br>       // 3. 从 <span class="hljs-built_in">set</span> 中查找元素 has()<br>       console.log(mySet.has(6)); //<span class="hljs-literal">false</span><br><br><br>       // 4. 清空所有元素 clear()<br>       mySet.clear();<br>       console.log(mySet);<br>   &lt;/script&gt;<br><br></code></pre></td></tr></table></figure><h3 id="22-set遍历"><a href="#22-set遍历" class="headerlink" title="22.set遍历"></a>22.set遍历</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;<br>        // 遍历 <span class="hljs-built_in">set</span> 类型的数据<br>        const mySet = new Set([2, 4, 5, 7])<br><br>        // 1. forEach() 方法遍历 <span class="hljs-built_in">set</span> 数据中的每个元素<br>        mySet.forEach(item =&gt; console.log(item))<br><br><br><br><br><br><br>        // 2. for...of 方法遍历任何可迭代的数据( Set, 数组, Map, 字符串)<br>        //遍历 <span class="hljs-built_in">set</span> 数据<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">let</span> item of mySet) &#123;<br>            console.log(item);<br>        &#125;<br>        console.log(<span class="hljs-string">&#x27;-------------------&#x27;</span>);<br>        // -------------------------------------------------------------------------------------------<br><br><br><br><br><br>        //遍历数组<br>        const arr2 = [1, 2, 3, 4, 5]<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">let</span> item of arr2) &#123;<br>            console.log(item);<br>            <span class="hljs-keyword">if</span> (item == 2) &#123; // for...of 遍历可以通过 <span class="hljs-keyword">if</span> 判断  <span class="hljs-built_in">break</span> 终止<br>                <span class="hljs-built_in">break</span><br>            &#125;<br>        &#125;<br>        console.log(<span class="hljs-string">&#x27;-------------------&#x27;</span>);<br>        // -------------------------------------------------------------------------------------------<br><br><br><br><br>        // 遍历字符串<br>        const str = <span class="hljs-string">&#x27;hello&#x27;</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">let</span> item of str) &#123;<br>            console.log(item);<br>        &#125;<br>        console.log(<span class="hljs-string">&#x27;-------------------&#x27;</span>);<br>        // -------------------------------------------------------------------------------------------<br><br><br><br>        // 注意: 对象不支持 for..of 方法 需要微调<br>        const obj = &#123;<br>                a: 1,<br>                b: 2,<br>                c: 3<br>            &#125;<br>            // <span class="hljs-keyword">for</span> (<span class="hljs-built_in">let</span> item of obj) &#123;<br>            //     console.log(item);<br>            // &#125;<br>            // console.log(<span class="hljs-string">&#x27;-------------------&#x27;</span>);//报错<br><br><br><br>        // 微调即可<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">let</span> item of Object.keys(obj)) &#123;<br>            console.log(item); //对象的属性名  a b c <br>            console.log(obj[item]); //属性值 1 2 3<br>        &#125;<br>        console.log(<span class="hljs-string">&#x27;-------------------&#x27;</span>);<br>    &lt;/script&gt;<br><br><br><br></code></pre></td></tr></table></figure><p>date: 2021-01-28 22:00:00<br>tags: [blog, hello]</p><hr>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/01/28/hello-world/"/>
    <url>/2021/01/28/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
